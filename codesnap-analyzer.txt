Project Directory: AIanalist
Total Files Analyzed: 107
Total Size: 0.33 MB
Date: 2025-01-01T11:16:59.855Z

Token counts by model:
   GPT-3.5: 70.7K
   GPT-4:   70.7K
   Claude:  70.7K
   LLaMA 2: 77.7K

Directory structure:
├── src/
│   ├── __mocks__/
│   │   ├── express-route-tracker/
│   │   │   └── dist.ts
│   │   ├── contact.firebase.ts
│   │   ├── express-rate-limit.ts
│   │   ├── firebase-admin.ts
│   │   └── helmet.ts
│   ├── _core/
│   │   ├── auth/
│   │   │   ├── guards/
│   │   │   │   └── jwt-auth.guard.ts
│   │   │   ├── strategies/
│   │   │   │   └── jwt.strategy.ts
│   │   │   ├── auth.controller.ts
│   │   │   ├── auth.dto.ts
│   │   │   ├── auth.handler.ts
│   │   │   ├── auth.interface.ts
│   │   │   ├── auth.module.ts
│   │   │   ├── auth.repository.ts
│   │   │   ├── auth.service.ts
│   │   │   ├── auth.validation.ts
│   │   │   └── index.ts
│   │   ├── config/
│   │   │   ├── dotenv.config.ts
│   │   │   └── firebase-admin.account.ts
│   │   ├── database/
│   │   │   └── firebase-admin-sdk/
│   │   │       └── index.ts
│   │   ├── helper/
│   │   │   ├── asyncHandler/
│   │   │   │   ├── __tests__/
│   │   │   │   │   └── asyncHandler.spec.ts
│   │   │   │   └── index.ts
│   │   │   ├── check-nodemon/
│   │   │   │   ├── __tests__/
│   │   │   │   │   └── isRunningWithNodemon.spec.ts
│   │   │   │   └── index.ts
│   │   │   ├── check-system-overload/
│   │   │   │   ├── __tests__/
│   │   │   │   │   └── check-system-overload.spec.ts
│   │   │   │   └── check-system-overload.ts
│   │   │   ├── http-status/
│   │   │   │   ├── common/
│   │   │   │   │   ├── __tests__/
│   │   │   │   │   │   ├── createPagination.spec.ts
│   │   │   │   │   │   └── RestHandler.spec.ts
│   │   │   │   │   ├── api-config.ts
│   │   │   │   │   ├── create-pagination.ts
│   │   │   │   │   ├── HttpStatusCode.ts
│   │   │   │   │   ├── RestHandler.ts
│   │   │   │   │   └── StatusCodes.ts
│   │   │   │   ├── error/
│   │   │   │   │   └── index.ts
│   │   │   │   ├── success/
│   │   │   │   │   └── index.ts
│   │   │   │   └── response-log.ts
│   │   │   ├── interfaces/
│   │   │   │   ├── CustomRequest.interface.ts
│   │   │   │   ├── FetchPageResult.interface.ts
│   │   │   │   └── rest.interface.ts
│   │   │   └── validateZodSchema/
│   │   │       ├── __tests__/
│   │   │       │   └── validateSchema.spec.ts
│   │   │       └── index.ts
│   │   ├── logger/
│   │   │   ├── __tests__/
│   │   │   │   └── simple-logger.spec.ts
│   │   │   └── simple-logger.ts
│   │   ├── middleware/
│   │   │   ├── __tests__/
│   │   │   │   ├── displayRequest.spec.ts
│   │   │   │   └── responseLogger.spec.ts
│   │   │   ├── auth.middleware.ts
│   │   │   ├── creates-HATEOAS.middleware.txt
│   │   │   ├── displayRequest.middleware.ts
│   │   │   ├── responseLogger.middleware.ts
│   │   │   └── start-time.middleware.ts
│   │   └── server/
│   │       ├── app/
│   │       │   ├── __tests__/
│   │       │   │   └── app.spec.ts
│   │       │   └── app.service.ts
│   │       └── server.ts
│   ├── models/
│   │   ├── Contact.model.ts
│   │   └── TradingEconomicsNew.model.ts
│   ├── modules/
│   │   ├── _base/
│   │   │   └── crud/
│   │   │       ├── BaseController.ts
│   │   │       ├── BaseRepository.ts
│   │   │       └── BaseService.ts
│   │   ├── contact/
│   │   │   ├── __tests__/
│   │   │   │   ├── contact-controller.spec.ts
│   │   │   │   ├── contact.handle.spec.ts
│   │   │   │   ├── contact.repository.spec.ts
│   │   │   │   ├── contact.route.spec.ts
│   │   │   │   └── contact.service.spec.ts
│   │   │   ├── contact.controller.ts
│   │   │   ├── contact.dto.ts
│   │   │   ├── contact.handler.ts
│   │   │   ├── contact.interface.ts
│   │   │   ├── contact.module.ts
│   │   │   ├── contact.repository.ts
│   │   │   ├── contact.service.ts
│   │   │   ├── contact.validation.ts
│   │   │   └── index.ts
│   │   ├── trading-economics-new/
│   │   │   ├── index.ts
│   │   │   ├── trading-economics-new.controller.ts
│   │   │   ├── trading-economics-new.dto.ts
│   │   │   ├── trading-economics-new.handler.ts
│   │   │   ├── trading-economics-new.interface.ts
│   │   │   ├── trading-economics-new.module.ts
│   │   │   ├── trading-economics-new.repository.ts
│   │   │   ├── trading-economics-new.service.ts
│   │   │   └── trading-economics-new.validation.ts
│   │   └── index.ts
│   ├── scripts/
│   │   ├── bot/
│   │   │   ├── __pycache__/
│   │   │   │   └── fetch-html-background.cpython-312.pyc
│   │   │   ├── fetch-html-background.py
│   │   │   ├── fetch-html.py
│   │   │   ├── fetch-single-url-html-background.py
│   │   │   └── test.py
│   │   ├── openai/
│   │   │   ├── __pycache__/
│   │   │   │   └── ask0.cpython-312.pyc
│   │   │   ├── config/
│   │   │   │   └── aianalist-firebase-adminsdk-8gwkb-09a794ac72.json
│   │   │   ├── analyze_news.py
│   │   │   └── ask0.py
│   │   └── test-path-converter.ts
│   └── utils/
│       ├── clean-doublon.ts
│       ├── fetch-content.ts
│       ├── firebase-utils.service.ts
│       ├── get-all-files.ts
│       ├── get-data.ts
│       ├── get-latest-file.ts
│       └── post-data.ts
├── .gitattributes
├── .gitignore
├── CHANGELOG.md
├── jest.config.ts
├── jest.setup.ts
├── package.json
├── query
├── readme.md
└── tsconfig.json

================================================
File: readme.md
================================================
# RESTful API Implementation Guide with Node.js, Express.js, and TypeScript
(on progress)
## 📚 **Project Foundation and Tools**
- **Node.js & Express.js:** Web server framework for handling HTTP requests.
- **TypeScript:** Strong typing and better development experience.
- **express-route-tracker:** Route management with HATEOAS support.
- **dotenv:** Environment variable management.
- **Firebase:** Database and authentication.

## 📖 **Key RESTful API Design Principles**
1. **Resources:** Represent data as resources (e.g., contacts, products).
2. **HTTP Methods:**
   - **GET:** Retrieve data.
   - **POST:** Create resources.
   - **PUT:** Fully update a resource.
   - **PATCH:** Partially update a resource.
   - **DELETE:** Remove a resource.
3. **Status Codes:** Use meaningful HTTP status codes (e.g., 200 OK, 201 Created, 400 Bad Request).
4. **HATEOAS:** Enable API discoverability through hypermedia links.
5. **JSON:** Use JSON for data exchange.

## 🛠️ **Implementation Steps**
### 1. **Router Creation**
- Use `createRouter(__filename)` for defining routes.

**Example:**
```typescript
import { createRouter } from 'express-route-tracker';
import { Router } from 'express';

const router: Router = createRouter(__filename);

router.get('/example', (req, res) => {
  res.json({ message: 'Hello from example route!' });
});

export default router;
```
- Track file sources with `express-route-tracker`.

### 2. **HATEOAS Integration**
- Add `createHATEOASMiddleware` to your routes.

**Example:**
```typescript
import { createHATEOASMiddleware } from 'express-route-tracker';
import { Router } from 'express';

const router: Router = createRouter(__filename);

router.use(createHATEOASMiddleware({
  autoIncludeSameRoute: true,
  baseUrl: '/api',
  includePagination: true,
  customLinks: {
    self: '/api/example',
    docs: '/api/docs'
  }
}));

router.get('/example', (req, res) => {
  res.json({ message: 'Hello with HATEOAS links!' });
});

export default router;
```
- Enable pagination and custom link generation.

### 3. **Module-Based Routes**
- Organize routes in dedicated directories (e.g., `src/modules/contact`).

### 4. **Controllers**
- Handle incoming requests.

**Example:**
```typescript
import { Request, Response } from 'express';
import { RestHandler } from '@/core/helper/http-status/common/RestHandler';

export const getExampleData = (req: Request, res: Response) => {
  try {
    const data = { id: 1, name: 'Sample Data' };
    RestHandler.success(req, res, {
      data,
      message: 'Data retrieved successfully'
    });
  } catch (error) {
    RestHandler.error(req, res, {
      message: 'Failed to retrieve data'
    });
  }
};
```
- Validate data using `validateSchema(CreateContactSchema)`.

### 5. **Services**
- Encapsulate business logic (e.g., `contact.service.ts`).

**Example:**
```typescript
import { firestore } from '@/core/database/firebase';

export class ContactService {
  async getContactById(contactId: string) {
    try {
      const contactRef = firestore.collection('contacts').doc(contactId);
      const doc = await contactRef.get();
      if (!doc.exists) {
        throw new Error('Contact not found');
      }
      return doc.data();
    } catch (error) {
      console.error('Failed to fetch contact:', error);
      throw error;
    }
  }

  async createContact(contactData: any) {
    try {
      const contactRef = await firestore.collection('contacts').add(contactData);
      return { id: contactRef.id, ...contactData };
    } catch (error) {
      console.error('Failed to create contact:', error);
      throw error;
    }
  }
}
```

### 6. **Repositories**
- Abstract data access logic (e.g., `contact.repository.ts`).

### 7. **Response Handling**
- Use `RestHandler.success` for successful responses.
- Use `RestHandler.error` for error responses.

### 8. **Validation**
- Employ **Zod** for schema-based input validation.

## 🔗 **HATEOAS Details**
- Automatically generates hypermedia links (`self`, `next`, `prev`).
- Pagination links are added with `includePagination`.

## ⚙️ **Configuration**
- `src/_core/helper/http-status/common/api-config.ts` manages API prefix, pagination, rate limits, and CORS.

## 🚨 **Error Management**
- Centralized error handling with `RestHandler.error`.
- Error codes defined in `HttpStatusCode.ts`.

## ✅ **Steps Summary**
1. Define Resources.
2. Map Routes.
3. Implement Controllers.
4. Add Services.
5. Create Repositories.
6. Integrate HATEOAS.
7. Validate Input.
8. Handle Errors.

## 📷 **Example Screenshot**
![Run](https://scontent.fctt1-1.fna.fbcdn.net/v/t1.15752-9/471453803_566124249589841_3236167951397755768_n.png?_nc_cat=110&ccb=1-7&_nc_sid=9f807c&_nc_ohc=D92g0dM9ZrYQ7kNvgHSxNH_&_nc_zt=23&_nc_ht=scontent.fctt1-1.fna&oh=03_Q7cD1gGOqt-n_WnUGkELyypLJfGj-a2mWbIntisgXIQsuBMkcg&oe=6799456B)

![Console Log request](https://scontent.fctt1-1.fna.fbcdn.net/v/t1.15752-9/462573393_637184128693842_7510104037535305269_n.png?_nc_cat=111&ccb=1-7&_nc_sid=9f807c&_nc_ohc=Q6xKSFbm_pwQ7kNvgE78TQJ&_nc_zt=23&_nc_ht=scontent.fctt1-1.fna&oh=03_Q7cD1gFwjoZ1Og6Xru1QNoShJ0b9aL6TVv0aeasS7VKq3GMb8g&oe=67995635)

![Important Log ](https://scontent.xx.fbcdn.net/v/t1.15752-9/462577183_1521197635219617_5938353982022041730_n.png?_nc_cat=101&ccb=1-7&_nc_sid=0024fc&_nc_ohc=RTO2q1A6qLQQ7kNvgE9_R6R&_nc_ad=z-m&_nc_cid=0&_nc_zt=23&_nc_ht=scontent.xx&oh=03_Q7cD1gGlC-hIQA6lKZpc2lKKNhaDcl9yeSVsi47Qk11CMW8cyA&oe=6799414E)

![Error Log ](https://scontent.fctt1-1.fna.fbcdn.net/v/t1.15752-9/462570903_1134773754680523_7473195736379572011_n.png?_nc_cat=100&ccb=1-7&_nc_sid=9f807c&_nc_ohc=ZSBpsy__irgQ7kNvgHaCzFl&_nc_zt=23&_nc_ht=scontent.fctt1-1.fna&oh=03_Q7cD1gGn1QhxqjAXyOfi9S3FUxTiuxAehA8y8G9tbQCGFaWKhA&oe=67995228)

---

## **Example Postman response**

```
{
    "success": true,
    "code": 200,
    "message": "Get contact by id successfully",
    "data": {
        "id": "yQg9OD4KRTNywa2fHwxN",
        "name": "Jett Zboncak",
        "email": "test.email19214@yopmail.com",
        "phone": "06 26 73 76 92",
        "message": "Interested in your services",
        "createdAt": {
            "_seconds": 1735267038,
            "_nanoseconds": 739000000
        },
        "updatedAt": {
            "_seconds": 1735267038,
            "_nanoseconds": 739000000
        }
    },
    "metadata": {
        "timestamp": "2024-12-29T22:50:17.735Z",
        "statusCode": "OK",
        "methode": "GET",
        "path": "/api/contact/yQg9OD4KRTNywa2fHwxN",
        "description": "The request has succeeded.",
        "documentation": "https://tools.ietf.org/html/rfc7231#section-6.3.1"
    },
    "links": {
        "self": {
            "rel": "self",
            "href": "localhost:3333/api/contact/yQg9OD4KRTNywa2fHwxN",
            "method": "GET"
        },
        "create": {
            "title": "POST /",
            "rel": "create",
            "href": "localhost:3333/api/contact/",
            "method": "POST"
        },
        "collection": {
            "title": "GET /",
            "rel": "collection",
            "href": "localhost:3333/api/contact/",
            "method": "GET"
        },
        "item": {
            "title": "GET /:id",
            "rel": "item",
            "href": "localhost:3333/api/contact/yQg9OD4KRTNywa2fHwxN",
            "method": "GET"
        },
        "update": {
            "title": "PUT /:id",
            "rel": "update",
            "href": "localhost:3333/api/contact/yQg9OD4KRTNywa2fHwxN",
            "method": "PUT"
        },
        "delete": {
            "title": "DELETE /:id",
            "rel": "delete",
            "href": "localhost:3333/api/contact/yQg9OD4KRTNywa2fHwxN",
            "method": "DELETE"
        },
        "documentation": {
            "rel": "documentation",
            "href": "localhost:3333/docs",
            "method": "GET",
            "title": "API Documentation"
        }
    }
}
```


Validation error
```
{
    "success": false,
    "code": 400,
    "message": "Validation Error",
    "errors": [
        {
            "field": "password",
            "message": "Password must be at least 8 characters long"
        },
        {
            "field": "password",
            "message": "Password must contain at least one lowercase letter"
        },
        {
            "field": "password",
            "message": "Password must contain at least one uppercase letter"
        },
        {
            "field": "password",
            "message": "Password must contain at least one special character"
        }
    ],
    "metadata": {
        "timestamp": "2024-12-30T14:36:52.645Z",
        "statusCode": "BAD_REQUEST",
        "description": "The server could not understand the request due to invalid syntax.",
        "documentation": "https://tools.ietf.org/html/rfc7231#section-6.5.1"
    },
    "links": {
        "self": {
            "rel": "self",
            "href": "localhost:3333/api/auth/registre",
            "method": "POST"
        },
        "post-registre": {
            "title": "POST /registre",
            "rel": "post-registre",
            "href": "localhost:3333/registre",
            "method": "POST"
        },
        "documentation": {
            "rel": "documentation",
            "href": "localhost:3333/docs",
            "method": "GET",
            "title": "API Documentation"
        }
    }
}
```

```

Directory structure:
└── AIanalist/
    ├── CHANGELOG.md
    ├── jest.config.ts
    ├── jest.setup.ts
    ├── package.json
    ├── query
    ├── readme.md
    ├── src/
    │   ├── __mocks__/
    │   │   ├── contact.firebase.ts
    │   │   ├── express-rate-limit.ts
    │   │   ├── express-route-tracker/
    │   │   │   └── dist.ts
    │   │   ├── firebase-admin.ts
    │   │   └── helmet.ts
    │   ├── _core/
    │   │   ├── auth/
    │   │   │   ├── auth.controller.ts
    │   │   │   ├── auth.dto.ts
    │   │   │   ├── auth.handler.ts
    │   │   │   ├── auth.interface.ts
    │   │   │   ├── auth.module.ts
    │   │   │   ├── auth.repository.ts
    │   │   │   ├── auth.service.ts
    │   │   │   ├── auth.validation.ts
    │   │   │   ├── guards/
    │   │   │   │   └── jwt-auth.guard.ts
    │   │   │   ├── index.ts
    │   │   │   └── strategies/
    │   │   │       └── jwt.strategy.ts
    │   │   ├── config/
    │   │   │   ├── dotenv.config.ts
    │   │   │   └── firebase-admin.account.ts
    │   │   ├── database/
    │   │   │   └── firebase-admin-sdk/
    │   │   │       └── index.ts
    │   │   ├── helper/
    │   │   │   ├── asyncHandler/
    │   │   │   │   ├── __tests__/
    │   │   │   │   │   └── asyncHandler.spec.ts
    │   │   │   │   └── index.ts
    │   │   │   ├── check-nodemon/
    │   │   │   │   ├── __tests__/
    │   │   │   │   │   └── isRunningWithNodemon.spec.ts
    │   │   │   │   └── index.ts
    │   │   │   ├── check-system-overload/
    │   │   │   │   ├── __tests__/
    │   │   │   │   │   └── check-system-overload.spec.ts
    │   │   │   │   └── check-system-overload.ts
    │   │   │   ├── http-status/
    │   │   │   │   ├── common/
    │   │   │   │   │   ├── HttpStatusCode.ts
    │   │   │   │   │   ├── RestHandler.ts
    │   │   │   │   │   ├── StatusCodes.ts
    │   │   │   │   │   ├── __tests__/
    │   │   │   │   │   │   ├── RestHandler.spec.ts
    │   │   │   │   │   │   └── createPagination.spec.ts
    │   │   │   │   │   ├── api-config.ts
    │   │   │   │   │   └── create-pagination.ts
    │   │   │   │   ├── error/
    │   │   │   │   │   └── index.ts
    │   │   │   │   ├── response-log.ts
    │   │   │   │   └── success/
    │   │   │   │       └── index.ts
    │   │   │   ├── interfaces/
    │   │   │   │   ├── CustomRequest.interface.ts
    │   │   │   │   ├── FetchPageResult.interface.ts
    │   │   │   │   └── rest.interface.ts
    │   │   │   └── validateZodSchema/
    │   │   │       ├── __tests__/
    │   │   │       │   └── validateSchema.spec.ts
    │   │   │       └── index.ts
    │   │   ├── logger/
    │   │   │   ├── __tests__/
    │   │   │   │   └── simple-logger.spec.ts
    │   │   │   └── simple-logger.ts
    │   │   ├── middleware/
    │   │   │   ├── __tests__/
    │   │   │   │   ├── displayRequest.spec.ts
    │   │   │   │   └── responseLogger.spec.ts
    │   │   │   ├── auth.middleware.ts
    │   │   │   ├── creates-HATEOAS.middleware.txt
    │   │   │   ├── displayRequest.middleware.ts
    │   │   │   └── responseLogger.middleware.ts
    │   │   └── server/
    │   │       ├── app/
    │   │       │   ├── __tests__/
    │   │       │   │   └── app.spec.ts
    │   │       │   └── app.service.ts
    │   │       └── server.ts
    │   ├── modules/
    │   │   ├── _base/
    │   │   │   └── crud/
    │   │   │       ├── BaseController.ts
    │   │   │       ├── BaseRepository.ts
    │   │   │       └── BaseService.ts
    │   │   ├── contact/
    │   │   │   ├── __tests__/
    │   │   │   │   ├── contact-controller.spec.ts
    │   │   │   │   ├── contact.handle.spec.ts
    │   │   │   │   ├── contact.repository.spec.ts
    │   │   │   │   ├── contact.route.spec.ts
    │   │   │   │   └── contact.service.spec.ts
    │   │   │   ├── contact.controller.ts
    │   │   │   ├── contact.dto.ts
    │   │   │   ├── contact.handler.ts
    │   │   │   ├── contact.interface.ts
    │   │   │   ├── contact.module.ts
    │   │   │   ├── contact.repository.ts
    │   │   │   ├── contact.service.ts
    │   │   │   ├── contact.validation.ts
    │   │   │   └── index.ts
    │   │   ├── index.ts
    │   │   └── trading-economics-new/
    │   │       ├── index.ts
    │   │       ├── trading-economics-new.controller.ts
    │   │       ├── trading-economics-new.dto.ts
    │   │       ├── trading-economics-new.handler.ts
    │   │       ├── trading-economics-new.interface.ts
    │   │       ├── trading-economics-new.module.ts
    │   │       ├── trading-economics-new.repository.ts
    │   │       ├── trading-economics-new.service.ts
    │   │       └── trading-economics-new.validation.ts
    │   ├── scripts/
    │   │   ├── bot/
    │   │   │   ├── fetch-html-background.py
    │   │   │   ├── fetch-html.py
    │   │   │   ├── fetch-single-url-html-background.py
    │   │   │   └── test.py
    │   │   ├── openai/
    │   │   │   ├── analyze_news.py
    │   │   │   ├── ask0.py
    │   │   │   └── config/
    │   │   │       └── aianalist-firebase-adminsdk-8gwkb-09a794ac72.json
    │   │   └── test-path-converter.ts
    │   └── utils/
    │       ├── clean-doublon.ts
    │       ├── fetch-content.ts
    │       ├── firebase-utils.service.ts
    │       ├── get-all-files.ts
    │       ├── get-data.ts
    │       ├── get-latest-file.ts
    │       └── post-data.ts
    └── tsconfig.json

```

By following these guidelines, you'll have a scalable and efficient RESTful API ready for production. 🚀

> For detailed code examples, check `src/modules/contact` in your project repository.

**Happy Coding! 🧑‍💻**


📃 License
This project is licensed under the MIT License.


================================================
File: .gitignore
================================================
# Logs
logs
*.log
npm-debug.log*

# venv
venv

# Dependency directories
node_modules/
bower_components/

# Build directories
dist/
build/
tmp/

# TypeScript
*.tsbuildinfo

# Angular
.angular/
.angular-cache/
src/environment/
environment/

# IDE files
.vscode/
.idea/
.DS_Store

# Operating system files
Thumbs.db

#env
.env

#backup
backup/

coverage/
fetch-data/
logs/


================================================
File: CHANGELOG.md
================================================
# Changelog

All notable changes to this project will be documented in this file. See [standard-version](https://github.com/conventional-changelog/standard-version) for commit guidelines.

### 1.0.1 (2024-09-08)


================================================
File: jest.config.ts
================================================
import type { Config } from 'jest';

const config: Config = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  testMatch: ['**/__tests__/**/*.spec.ts'],
  moduleFileExtensions: ['ts', 'js', 'json'],
  verbose: true,
  clearMocks: true,
  transform: {
    '^.+\\.tsx?$': 'ts-jest'
  },
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/src/$1',
    '^@src/(.*)$': '<rootDir>/src/$1',
    '^@scripts/(.*)$': '<rootDir>/src/scripts/$1',
    '^@utils/(.*)$': '<rootDir>/src/utils/$1',
    '^@modules/(.*)$': '<rootDir>/src/modules/$1',
    '^@server/(.*)$': '<rootDir>/src/_core/server/$1',
    '^@database/(.*)$': '<rootDir>/src/_core/database/$1',
    '^@env/(.*)$': '<rootDir>/src/_core/config/$1',
    '^@config/(.*)$': '<rootDir>/src/_core/config/$1',
    '^@environment/(.*)$': '<rootDir>/environment/$1',
    'express-route-tracker/dist': '<rootDir>/src/__mocks__/express-route-tracker/dist',
    'helmet/index.cjs': '<rootDir>/node_modules/helmet/index.cjs',
    'express-rate-limit': '<rootDir>/src/__mocks__/express-rate-limit',
    'helmet': '<rootDir>/src/__mocks__/helmet'

  },
  setupFiles: ['dotenv/config'],
  setupFilesAfterEnv: ['<rootDir>/jest.setup.ts'],
  extensionsToTreatAsEsm: ['.ts'],
  rootDir: './'
};

export default config;

================================================
File: jest.setup.ts
================================================
const dotenv = require('dotenv');

dotenv.config({ path: '@environment/.env.test' });

================================================
File: package.json
================================================
{
	"name": "aianalist",
	"version": "1.0.1",
	"description": "",
	"main": "index.js",
	"scripts": {
		"ttt": "ts-node -r tsconfig-paths/register src/scripts/test-path-converter.ts",
		"test": "jest",
		"test:watch": "jest --watch",
		"test:coverage": "jest --coverage",
		"build": "tsc",
		"start": "cross-env NODE_ENV=production node -r tsconfig-paths/register dist/_core/server/server.js",
		"dev": "cross-env NODE_ENV=development NODEMON=true nodemon --watch src/**/*.ts --exec ts-node -r tsconfig-paths/register src/_core/server/server.ts"
	},
	"keywords": [],
	"author": "",
	"license": "ISC",
	"dependencies": {
		"aianalist": "file:",
		"cli-table3": "^0.6.5",
		"codesnap": "^0.0.4",
		"colorette": "^2.0.20",
		"cors": "^2.8.5",
		"dotenv": "^16.4.5",
		"express": "^4.19.2",
		"express-rate-limit": "^7.5.0",
		"express-route-tracker": "^2.0.62",
		"firebase": "^10.13.1",
		"helmet": "^8.0.0",
		"jsonwebtoken": "^9.0.2",
		"lodash": "^4.17.21",
		"python-shell": "^5.0.0",
		"reflect-metadata": "^0.2.2",
		"selenium": "^2.20.0",
		"typedi": "^0.10.0",
		"zod": "^3.24.1"
	},
	"devDependencies": {
		"@firebase/testing": "^0.20.11",
		"@types/cors": "^2.8.17",
		"@types/express": "^4.17.21",
		"@types/jest": "^29.5.14",
		"@types/jsonwebtoken": "^9.0.7",
		"@types/lodash": "^4.17.7",
		"@types/node": "^22.5.4",
		"@types/supertest": "^6.0.2",
		"cross-env": "^7.0.3",
		"firebase-admin": "^13.0.2",
		"husky": "^9.1.5",
		"jest": "^29.7.0",
		"nodemon": "^3.1.9",
		"rimraf": "^6.0.1",
		"standard-version": "^9.5.0",
		"supertest": "^7.0.0",
		"ts-jest": "^29.2.5",
		"ts-node": "^10.9.2",
		"tsconfig-paths": "^4.2.0",
		"typescript": "^5.5.4"
	},
	"overrides": {
		"node-fetch": "^2.6.7",
		"tough-cookie": "^4.1.3"
	}
}


================================================
File: query
================================================
HTMLFetcherService


================================================
File: src/__mocks__/contact.firebase.ts
================================================
export const firestore = {
  collection: jest.fn(() => ({
    add: jest.fn((data) => Promise.resolve({ id: '123', ...data })),
    doc: jest.fn(() => ({
      get: jest.fn(() => Promise.resolve({
        exists: true,
        id: '123',
        data: () => ({ name: 'Test', email: 'test@test.com', phone: '1234567890' })
      })),
      update: jest.fn(),
      delete: jest.fn()
    })),
    get: jest.fn(() => Promise.resolve({
      docs: [
        {
          id: '123',
          data: () => ({ name: 'Test', email: 'test@test.com', phone: '1234567890' })
        }
      ]
    }))
  }))
};

================================================
File: src/__mocks__/express-rate-limit.ts
================================================
const rateLimit = jest.fn(() => (_req: any, _res: any, next: any) => next());
export default rateLimit;

================================================
File: src/__mocks__/express-route-tracker/dist.ts
================================================
import { Router } from 'express';

export const createRouter = jest.fn((filename: string) => {
    console.log('Mocked createRouter called with filename:', filename);
    return Router();
});

================================================
File: src/__mocks__/firebase-admin.ts
================================================
export const initializeApp = jest.fn();
export const credential = {
	cert: jest.fn()
};
export const firestore = jest.fn();
export const auth = jest.fn();
export const database = jest.fn();


================================================
File: src/__mocks__/helmet.ts
================================================
export default jest.fn(() => (_req: any, _res: any, next: any) => next());


================================================
File: src/_core/auth/auth.controller.ts
================================================
import _SUCCESS from '@/_core/helper/http-status/success';
import { RequestHandler, Response } from 'express';
import _ERROR from '../helper/http-status/error';
import { CustomRequest } from '../helper/interfaces/CustomRequest.interface';
import { AuthService } from './auth.service';
import { IAuth, IRegister } from './auth.interface';

class AuthController {
  constructor(
    private authService: AuthService,
  ) {
  }

  register: RequestHandler = async (req: CustomRequest, res: Response) => {
    const body = req.body as IRegister;
    const result = await this.authService.register(body);
    new _SUCCESS.CreatedSuccess({
      message: 'User registered successfully',
      data: result
    })
      .setResponseTime(req.startTime)
      .send(res);
  }

  login: RequestHandler = async (req: CustomRequest, res: Response) => {
    const { email, password } = req.body as IAuth;
    const result = await this.authService.login(email, password);
    new _SUCCESS.OkSuccess({
      message: 'User logged in successfully',
      data: result
    })
      .setResponseTime(req.startTime)
      .send(res);
  }

  getCurrentUser: RequestHandler = async (req: CustomRequest, res: Response) => {
    if (!req.user) {
      throw new _ERROR.UnauthorizedError({
        message: 'Unauthorized: No user found'
      });
    }
    const result = await this.authService.getUser(req.user.uid);
    new _SUCCESS.OkSuccess({
      message: 'User fetched successfully',
      data: result
    })
      .setResponseTime(req.startTime)
      .send(res);
  }

  verifyToken: RequestHandler = async (req: CustomRequest, res: Response) => {
    const token = req.headers.authorization?.split(' ')[1] || '';
    const result = await this.authService.verifyToken(token);
    new _SUCCESS.OkSuccess({
      message: 'Token verified successfully',
      data: result
    })
      .setResponseTime(req.startTime)
      .send(res);
  }
}

export default AuthController;

================================================
File: src/_core/auth/auth.dto.ts
================================================
import { z } from "zod";
import { LoginSchema, RegisterSchema } from "./auth.validation";


export type LoginInput = z.infer<typeof LoginSchema>;
export type RegisterInput = z.infer<typeof RegisterSchema>;

================================================
File: src/_core/auth/auth.handler.ts
================================================
import { Request, Response, NextFunction } from 'express';
import { RegisterSchema, LoginSchema } from './auth.validation';
import { authController } from './auth.module';
import { validateDTO } from '../helper/validateZodSchema';

const validateRegisterDTO = validateDTO(RegisterSchema, 'body');
const validateLoginDTO = validateDTO(LoginSchema, 'body');

const registerHandler = async (req: Request, res: Response, next: NextFunction) => {
  try {
    // Validation already happened in middleware
    await authController.register(req, res, next);
  } catch (error) {
    next(error);
  }
};


const loginHandler = async (req: Request, res: Response, next: NextFunction): Promise<any> => {
  try {
    // Validation already happened in middleware
    await authController.login(req, res, next);
  } catch (error) {
    next(error);
  }
};

const getCurrentUserHandler = async (req: Request, res: Response, next: NextFunction): Promise<any> => {
  try {
    await authController.getCurrentUser(req, res, next);
  } catch (error) {
    next(error);
  }
};

const verifyTokenHandler = async (req: Request, res: Response, next: NextFunction): Promise<any> => {
  try {
    await authController.verifyToken(req, res, next);
  } catch (error) {
    next(error);
  }
}

export {
  validateRegisterDTO,
  validateLoginDTO,
  registerHandler,
  loginHandler,
  getCurrentUserHandler,
  verifyTokenHandler
}

================================================
File: src/_core/auth/auth.interface.ts
================================================
// contact.interface.ts
export interface IAuth {
    email: string;
    password: string;
}

export interface IRegister {
    email: string;
    password: string;
    firstName: string;
    lastName: string;
    phone: string;
    address: string;
    postalCode: string;
    city: string;
    country: string;
 }

================================================
File: src/_core/auth/auth.module.ts
================================================
import AuthRepository from './auth.repository';
import AuthService from './auth.service';
import AuthController from './auth.controller';
import { contactService } from '@/modules/contact/contact.module';

class AuthModule {
    public authRepository: AuthRepository;
    public authService: AuthService;
    public authController: AuthController;

    constructor() {
        this.authRepository = new AuthRepository();
        this.authService = new AuthService(this.authRepository, contactService);
        this.authController = new AuthController(this.authService);
    }
}

const authModule = new AuthModule();

export const { authController, authService, authRepository } = authModule;


================================================
File: src/_core/auth/auth.repository.ts
================================================
import { UserCredential, createUserWithEmailAndPassword, signInWithEmailAndPassword } from 'firebase/auth';
import { UserRecord } from 'firebase-admin/auth';
import { firebaseAdminAuth, firebaseClientAuth } from '../database/firebase-admin-sdk';
import { DecodedIdToken } from 'firebase-admin/auth';
import { IAuth } from './auth.interface';
import _ERROR from '../helper/http-status/error';

class AuthRepository {
    async createUser(account: IAuth): Promise<UserCredential> {
        try {
            return await createUserWithEmailAndPassword(firebaseClientAuth, account.email, account.password);
        } catch (error: any) {
            switch (error.code) {
                case 'auth/email-already-in-use':
                    throw new _ERROR.ConflictError({ message: 'Email is already in use' });
                case 'auth/invalid-email':
                    throw new _ERROR.BadRequestError({ message: 'Invalid email format' });
                case 'auth/weak-password':
                    throw new _ERROR.BadRequestError({ message: 'Password is too weak' });
                default:
                    throw new _ERROR.InternalServerError({ message: 'Failed to register user' });
            }
        }
    }

    async loginUser(email: string, password: string): Promise<UserCredential> {
        try {
            return await signInWithEmailAndPassword(
                firebaseClientAuth,
                email,
                password
            );
        } catch (error: any) {
            console.error('❌ Firebase Login Error:', error);
            throw error;
        }
    }

    async verifyIdToken(token: string): Promise<DecodedIdToken> {
        try {
            return await firebaseAdminAuth.verifyIdToken(token);
        } catch (error: any) {
            console.error('❌ Firebase Token Verification Error:', error);
            throw error;
        }
    }

    async getUserById(uid: string): Promise<UserRecord> {
        try {
            return await firebaseAdminAuth.getUser(uid);
        } catch (error: any) {
            console.error('❌ Firebase Get User Error:', error);
            throw error;
        }
    }
}

export default AuthRepository;

================================================
File: src/_core/auth/auth.service.ts
================================================
// src/_core/auth/services/auth.service.ts
import { DecodedIdToken, UserRecord } from 'firebase-admin/auth';
import { UserCredential } from 'firebase/auth';
import _ERROR from '../helper/http-status/error';
import { IRegister } from './auth.interface';
import AuthRepository from './auth.repository';
import ContactService from '@/modules/contact/contact.service';

export class AuthService {
    constructor(
        private authRepository: AuthRepository,
        private contactService: ContactService
    ) {}

    async register(registerData: IRegister): Promise<UserCredential> {
        const { email, password, ...contactData } = registerData;
        
        const userCred = await this.authRepository.createUser({ email, password });
        
        await this.contactService.createWithId(userCred.user.uid, {
            ...contactData,
            email,
        });
        
        return userCred;
     }

     async login(email: string, password: string): Promise<{ token: string; refreshToken: string }> {
        try {
            console.log(`Logging in user: ${email}`);
            const userCredential = await this.authRepository.loginUser(email, password);
            
            const user = userCredential.user;
            console.log(`✅ User logged in successfully: ${user.uid}`);
    
            const token = await user.getIdToken();
            const refreshToken = user.refreshToken; // Retrieve the refresh token
    
            return { token, refreshToken };
        } catch (error: any) {
            console.error('❌ Login Error:', error);
            if (['auth/user-not-found', 'auth/wrong-password', 'auth/invalid-credential'].includes(error.code)) {
                throw new _ERROR.UnauthorizedError({
                    message: 'Invalid email or password'
                });
            }
            throw new _ERROR.UnauthorizedError({
                message: 'Failed to login'
            });
        }
    }
    

    async verifyToken(token: string): Promise<DecodedIdToken> {
        try {
            const decodedToken = await this.authRepository.verifyIdToken(token);
            console.log(`✅ Token verified successfully: ${decodedToken.uid}`);
            return decodedToken;
        } catch (error) {
            throw new _ERROR.UnauthorizedError({
                message: 'Invalid or expired token'
            });
        }
    }

    async getUser(uid: string): Promise<UserRecord> {
        try {
            console.log(`Fetching user details for UID: ${uid}`);
            const userRecord = await this.authRepository.getUserById(uid);
            console.log(`✅ User details fetched successfully: ${userRecord.email}`);
            return userRecord;
        } catch (error) {
            throw new _ERROR.UnauthorizedError({
                message: 'Failed to fetch user details'
            });
        }
    }
}

export default AuthService;

================================================
File: src/_core/auth/auth.validation.ts
================================================
import { z } from 'zod';

/**
 * User Login Validation Schema
 */
export const LoginSchema = z.object({
  email: z.string().email('Invalid email format').min(1, 'Email is required'),
  password: z.string().min(1, 'Password is required')
});

/**
 * User Registration Validation Schema
 */
export const RegisterSchema = z.object({
  email: z.string().email('Invalid email format').min(1, 'Email is required'),
  password: z
    .string()
    .min(8, 'Password must be at least 8 characters long')
    .regex(/[a-z]/, 'Password must contain at least one lowercase letter')
    .regex(/[A-Z]/, 'Password must contain at least one uppercase letter')
    .regex(/[0-9]/, 'Password must contain at least one digit')
    .regex(/[^a-zA-Z0-9]/, 'Password must contain at least one special character'),
  firstName: z.string().min(1, 'First name is required'),
  lastName: z.string().min(1, 'Last name is required'),
  phone: z.string().min(10, 'Phone number must be at least 10 digits'),
  address: z.string().min(1, 'Address is required'),
  postalCode: z.string().min(1, 'Postal code is required'),
  city: z.string().min(1, 'City is required'),
  country: z.string().min(1, 'Country is required')
});




================================================
File: src/_core/auth/guards/jwt-auth.guard.ts
================================================
import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';

const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key';

/**
 * Middleware to verify JWT token and attach user payload to the request.
 */
export function jwtAuthMiddleware(req: Request, res: Response, next: NextFunction) {
    const token = req.headers.authorization?.split(' ')[1]; // Extract token from Authorization header

    if (!token) {
        return res.status(401).json({
            success: false,
            message: 'Unauthorized: No token provided',
        });
    }

    try {
        const decoded = jwt.verify(token, JWT_SECRET);
        (req as any).user = decoded; // Attach decoded token payload to req.user
        next(); // Proceed to the next middleware or route handler
    } catch (error) {
        console.error('JWT Auth Error:', error);
        return res.status(401).json({
            success: false,
            message: 'Unauthorized: Invalid or expired token',
        });
    }
}


================================================
File: src/_core/auth/index.ts
================================================
// import { config } from '../config/dotenv.config';
import { createHATEOASMiddleware, createRouter } from 'express-route-tracker';
import { config } from '@config/dotenv.config';
import { asyncHandler } from '../helper/asyncHandler';
import { getCurrentUserHandler, loginHandler, registerHandler, validateLoginDTO, validateRegisterDTO, verifyTokenHandler } from './auth.handler';

const router = createRouter(__filename);

router.use(createHATEOASMiddleware(router, {
  autoIncludeSameRoute: true,
  baseUrl: config.baseUrl,
  includePagination: true,
  customLinks: {
      documentation: (_req) => ({
          rel: 'documentation',
          href: config.baseUrl+'/docs',
          method: 'GET',
          'title': 'API Documentation'
      })
  }
}));

/**
 * 🔐 User Registration
 */
router.post('/registre', validateRegisterDTO, asyncHandler(registerHandler));
router.post('/login', validateLoginDTO, asyncHandler(loginHandler));
router.get('/current', asyncHandler(getCurrentUserHandler));
router.get('/verify', asyncHandler(verifyTokenHandler));

export = router;


================================================
File: src/_core/auth/strategies/jwt.strategy.ts
================================================
import { Request, Response, NextFunction } from 'express';
import jwt, { JwtPayload } from 'jsonwebtoken';

const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key';

/**
 * Middleware to validate JWT and attach payload to request
 */
export function jwtStrategyMiddleware(req: Request, res: Response, next: NextFunction) {
    const token = req.headers.authorization?.split(' ')[1]; // Extract token from Bearer header

    if (!token) {
        return res.status(401).json({
            success: false,
            message: 'Unauthorized: No token provided',
        });
    }

    try {
        const payload = jwt.verify(token, JWT_SECRET) as JwtPayload;
        (req as any).user = payload; // Attach the decoded payload to req.user
        next(); // Proceed to the next middleware or route handler
    } catch (error) {
        console.error('JWT Validation Error:', error);
        return res.status(401).json({
            success: false,
            message: 'Unauthorized: Invalid or expired token',
        });
    }
}


================================================
File: src/_core/config/dotenv.config.ts
================================================
// src/_core/config/dotenv.ts
import dotenv from 'dotenv';
import path from 'path';
import { version, name } from '../../../package.json';
const env = process.env.NODE_ENV || 'development';
import {isEmpty} from 'lodash';
// Load base .env file first
dotenv.config();

// Then load environment specific .env file
const envFile = path.resolve(process.cwd(), `environment/.env.${env}`);
dotenv.config({ path: envFile });

export const config = {
    appName: name || 'Unknown App',
    appVersion : version || 'Unknown Version',
    baseApi: process.env.BASE_API || '/undefined',
    env: env || 'development',
    mode: process.env.MODE || 'development',
    port: process.env.PORT || 3000,
    host: process.env.HOST || 'localhost',
    dbUri: process.env.DATABASE_URI || 'mongodb://localhost:27017/mydatabase',
    dbName: process.env.DATABASE_NAME || 'mydatabase',
    logDir: process.env.LOG_DIR || 'logs',
    get baseUrl() {
        return this.mode === 'development' 
            ? `${this.host}:${this.port}`
            : this.host;
    }
};

export const firebaseConfig = {
    apiKey: process.env.FIREBASE_API_KEY,
    authDomain: process.env.FIREBASE_AUTH_DOMAIN,
    databaseURL: process.env.FIREBASE_DATABASE_URL,
    projectId: process.env.FIREBASE_PROJECT_ID,
    storageBucket: process.env.FIREBASE_STORAGE_BUCKET,
    messagingSenderId: process.env.FIREBASE_MESSAGING_SENDER_ID,
    appId: process.env.FIREBASE_APP_ID,
    measurementId: process.env.FIREBASE_MEASUREMENT_ID
};

export function showConfig(): string {
    if (isEmpty(config)) {
        return '❌ Config not loaded';
    } else {
        return `✅ Config: ${JSON.stringify(config, null, 2)}`;
    }
}




================================================
File: src/_core/config/firebase-admin.account.ts
================================================
import * as jsonData from '@environment/ai-analyst-14876-firebase-adminsdk-euw8h-703ddf3555.json';
export const firebaseAdminAccount = jsonData;
 

================================================
File: src/_core/database/firebase-admin-sdk/index.ts
================================================
import { firebaseConfig } from '@/_core/config/dotenv.config';
import { firebaseAdminAccount } from '@/_core/config/firebase-admin.account';
import { red, yellow } from 'colorette';
import { cert, getApp, getApps, initializeApp as initializeAdminApp } from 'firebase-admin/app';
import { getAuth as getAdminAuth, Auth as AdminAuth } from 'firebase-admin/auth';
import { getDatabase } from 'firebase-admin/database';
import { getFirestore } from 'firebase-admin/firestore';
import { getApps as getClientApps, initializeApp as initializeClientApp, getApp as getClientApp } from 'firebase/app';
import { getAuth as getClientAuth, Auth as ClientAuth } from 'firebase/auth';

let firebaseAdminApp;
let firebaseClientApp;
let firebaseAdminAuth: AdminAuth;
let firebaseClientAuth: ClientAuth;

// ✅ Initialize Firebase Admin SDK
try {
    if (!getApps().length) {
        firebaseAdminApp = initializeAdminApp({
            credential: cert(firebaseAdminAccount as any),
            databaseURL: process.env.FIREBASE_DATABASE_URL || 'https://ai-analyst-14876.firebaseio.com',
        });
        firebaseAdminAuth = getAdminAuth(firebaseAdminApp);
        console.log(yellow('✅ Firebase Admin initialized'));
    } else {
        firebaseAdminApp = getApp();
        firebaseAdminAuth = getAdminAuth(firebaseAdminApp);
        console.log(yellow('⚠️ Firebase Admin already initialized'));
    }
} catch (error) {
    console.error(red('❌ Failed to initialize Firebase Admin SDK:'), error);
    throw error;
}

// ✅ Initialize Firebase Client SDK
try {
    if (!getClientApps().length) {
        firebaseClientApp = initializeClientApp(firebaseConfig);
        firebaseClientAuth = getClientAuth(firebaseClientApp);
        console.log(yellow('✅ Firebase Client initialized'));
    } else {
        firebaseClientApp = getClientApp();
        firebaseClientAuth = getClientAuth(firebaseClientApp);
        console.log(yellow('⚠️ Firebase Client already initialized'));
    }
} catch (error) {
    console.error(red('❌ Failed to initialize Firebase Client SDK:'), error);
    throw error;
}

// ✅ Initialize Firestore and Realtime Database
const firestore = getFirestore(firebaseAdminApp);
const database = getDatabase(firebaseAdminApp);

// ✅ Test Firestore Access
async function testFirestoreAccess() {
    try {
        const testDoc = firestore.collection('test').doc('testDoc');
        await testDoc.set({ testField: 'testValue' });
        console.log(yellow('✅ Firestore access test successful'));
    } catch (error) {
        console.error(red('❌ Firestore access test failed:'), error);
    }
}

export {
    database,
    firebaseAdminApp,
    firebaseAdminAuth,
    firebaseClientApp,
    firebaseClientAuth,
    firestore,
    testFirestoreAccess,
};


================================================
File: src/_core/helper/asyncHandler/__tests__/asyncHandler.spec.ts
================================================
import { Request, Response, NextFunction } from 'express';
import { asyncHandler } from '..';

describe('asyncHandler', () => {
    let mockReq: Partial<Request>;
    let mockRes: Partial<Response>;
    let mockNext: jest.Mock;

    beforeEach(() => {
        mockReq = {};
        mockRes = {
            json: jest.fn(),
            status: jest.fn()
        };
        mockNext = jest.fn();
    });

    it('should handle successful async operations', async () => {
        const mockFunction = jest.fn().mockResolvedValue({ data: 'success' });
        const handler = asyncHandler(mockFunction);

        await handler(mockReq as Request, mockRes as Response, mockNext as NextFunction);

        expect(mockFunction).toHaveBeenCalledWith(mockReq, mockRes, mockNext);
        expect(mockNext).not.toHaveBeenCalled();
    });

    it('should pass errors to next middleware', async () => {
        const error = new Error('Test error');
        const mockFunction = jest.fn().mockRejectedValue(error);
        const handler = asyncHandler(mockFunction);

        await handler(mockReq as Request, mockRes as Response, mockNext);

        expect(mockFunction).toHaveBeenCalledWith(mockReq, mockRes, mockNext);
        expect(mockNext).toHaveBeenCalledWith(error);
    });   
});

================================================
File: src/_core/helper/asyncHandler/index.ts
================================================
import { NextFunction, Request, Response } from 'express';
type AsyncFunction = (
  req: Request,
  res: Response,
  next: NextFunction
) => Promise<any>;

export const asyncHandler = (fn: AsyncFunction) => {
  return (req: Request, res: Response, next: NextFunction): void => {
    if (res.headersSent) {
      return;
    }
    Promise.resolve(fn(req, res, next)).catch(next);
  };
};


================================================
File: src/_core/helper/check-nodemon/__tests__/isRunningWithNodemon.spec.ts
================================================
import { isRunningWithNodemon } from "..";

describe('isRunningWithNodemon', () => {
    const originalEnv = process.env;
    const originalArgv = process.argv;

    beforeEach(() => {
        process.env = { ...originalEnv };
        process.argv = [...originalArgv];
    });

    afterEach(() => {
        process.env = originalEnv;
        process.argv = originalArgv;
    });

    it('should return true when NODEMON env is true', () => {
        process.env.NODEMON = 'true';
        expect(isRunningWithNodemon()).toBe(true);
    });

    it('should return true when NODE_ENV is development', () => {
        process.env.NODE_ENV = 'development';
        expect(isRunningWithNodemon()).toBe(true);
    });

    it('should return true when argv includes nodemon', () => {
        process.argv.push('nodemon');
        expect(isRunningWithNodemon()).toBe(true);
    });

    it('should return false when no nodemon conditions are met', () => {
        delete process.env.NODEMON;
        process.env.NODE_ENV = 'production';
        process.argv = ['node', 'script.js'];
        expect(isRunningWithNodemon()).toBe(false);
    });
});

================================================
File: src/_core/helper/check-nodemon/index.ts
================================================
import { yellow } from "colorette";

export function isRunningWithNodemon(): boolean {
    return process.env.NODEMON === 'true' || process.env.NODE_ENV === 'development' || process.argv.some(arg => arg.includes('nodemon'));
  }

if (isRunningWithNodemon()) {
    console.log(yellow('✅ Application is running with Nodemon!'));
} else {
    console.error('❌ Application is running without Nodemon!');
}

================================================
File: src/_core/helper/check-system-overload/__tests__/check-system-overload.spec.ts
================================================
import os from 'os';
import process from 'process';
import { database } from '@/_core/database/firebase-admin-sdk';
import { checkSystemOverload } from '../check-system-overload';

// ✅ Mock system modules and Firebase
jest.mock('os');
jest.mock('@/_core/database/firebase', () => ({
  database: {
    ref: jest.fn(() => ({
      once: jest.fn(),
    })),
  },
}));

jest.useFakeTimers(); // Control `setInterval`

describe('checkSystemOverload', () => {
  const consoleLogSpy = jest.spyOn(console, 'log').mockImplementation();
  const consoleErrorSpy = jest.spyOn(console, 'error').mockImplementation();

  beforeEach(() => {
    jest.clearAllMocks();
    jest.spyOn(process, 'memoryUsage').mockReturnValue({
      rss: 500000000, // ~500 MB
      heapTotal: 0,
      heapUsed: 0,
      external: 0,
      arrayBuffers: 0,
    });
  });

  afterAll(() => {
    jest.restoreAllMocks();
    jest.useRealTimers();
  });

  // ✅ Test: Log system resource usage
  it('should log system resource usage', async () => {
    // Mock CPU cores
    (os.cpus as jest.Mock).mockReturnValue([{}, {}, {}, {}]); // 4 cores

    // Mock database usage
    (database.ref as jest.Mock).mockReturnValue({
      once: jest.fn().mockResolvedValue({
        numChildren: () => 10,
      }),
    });

    // Call the function
    checkSystemOverload();

    // Advance timers and resolve promises
    jest.advanceTimersByTime(10000); // 10 seconds
    await Promise.resolve(); // Allow pending promises to resolve

    // Validate logs
    expect(consoleLogSpy).toHaveBeenCalledWith(expect.stringContaining('Memory usage :: 476.837158203125 MB'));
    expect(consoleLogSpy).toHaveBeenCalledWith(expect.stringContaining('maxConnections accept :: 20'));
    expect(consoleLogSpy).toHaveBeenCalledWith('Admin SDK does not directly monitor connection status.');
    expect(consoleLogSpy).toHaveBeenCalledWith('Number of documents (children) in Realtime Database: 10');
  });

  // ✅ Test: Handle database errors gracefully
  it('should handle database errors gracefully', async () => {
    // Mock CPU cores
    (os.cpus as jest.Mock).mockReturnValue([{}, {}, {}]); // 3 cores

    // Mock database error
    (database.ref as jest.Mock).mockReturnValue({
      once: jest.fn().mockRejectedValue(new Error('Database access failed')),
    });

    // Call the function
    checkSystemOverload();

    // Advance timers and resolve promises
    jest.advanceTimersByTime(10000); // 10 seconds
    await Promise.resolve(); // Allow pending promises to resolve

    // Validate logs
    expect(consoleLogSpy).toHaveBeenCalledWith(expect.stringContaining('Memory usage :: 476.837158203125 MB'));
    expect(consoleLogSpy).toHaveBeenCalledWith(expect.stringContaining('maxConnections accept :: 15'));
    expect(consoleLogSpy).toHaveBeenCalledWith('Admin SDK does not directly monitor connection status.');
    expect(consoleErrorSpy).toHaveBeenCalledWith(
      '❌ Error accessing Realtime Database:',
      expect.any(Error)
    );
  });
});


================================================
File: src/_core/helper/check-system-overload/check-system-overload.ts
================================================
import { database } from '@/_core/database/firebase-admin-sdk';
import os from 'os';
import process from 'process';

const _SECONDS = 10000;

// ✅ Check system resource usage and log if there is an overload
export const checkSystemOverload = (): void => {
	setInterval(async () => {
		const numCores = os.cpus().length;
		const memoryUsage = process.memoryUsage().rss;

		const maxConnections = numCores * 5; // Define your own threshold here

		console.log(`Memory usage :: ${memoryUsage / 1024 / 1024} MB`);
		console.log(`maxConnections accept :: ${maxConnections}`);

		// ✅ Monitor connection status (Admin SDK does not support `.info/connected`)
		console.log('Admin SDK does not directly monitor connection status.');

		// ✅ Monitor Realtime Database read/writes (Admin SDK Example)
		const monitorDatabaseUsage = async () => {
			const ref = database.ref('news'); // Admin SDK uses `ref()` directly
			try {
				const snapshot = await ref.once('value');
				const docCount = snapshot.numChildren();
				console.log(`Number of documents (children) in Realtime Database: ${docCount}`);
			} catch (error) {
				console.error('❌ Error accessing Realtime Database:', error);
			}
		};

		monitorDatabaseUsage();
	}, _SECONDS); // Monitor every 10 seconds
};


================================================
File: src/_core/helper/http-status/common/__tests__/createPagination.spec.ts
================================================
import { API_CONFIG } from "../api-config";
import { createPagination } from "../create-pagination";

describe('createPagination', () => {
    const mockData = [
        { id: 1, name: 'Item 1' },
        { id: 2, name: 'Item 2' },
        { id: 3, name: 'Item 3' },
    ];

    it('should create pagination with default values', () => {
        const result = createPagination(mockData, 3);
        
        expect(result).toEqual({
            data: mockData,
            meta: {
                page: API_CONFIG.PAGINATION.DEFAULT_PAGE,
                limit: API_CONFIG.PAGINATION.DEFAULT_LIMIT,
                totalItems: 3,
                totalPages: 1,
                hasNext: false,
                hasPrev: false
            }
        });
    });

    it('should calculate total pages correctly', () => {
        const result = createPagination(mockData, 10, 1, 3);
        
        expect(result.meta).toEqual({
            page: 1,
            limit: 3,
            totalItems: 10,
            totalPages: 4,
            hasNext: true,
            hasPrev: false
        });
    });

    it('should handle middle page navigation', () => {
        const result = createPagination(mockData, 10, 2, 3);
        
        expect(result.meta).toEqual({
            page: 2,
            limit: 3,
            totalItems: 10,
            totalPages: 4,
            hasNext: true,
            hasPrev: true
        });
    });

    it('should handle last page navigation', () => {
        const result = createPagination(mockData, 10, 4, 3);
        
        expect(result.meta).toEqual({
            page: 4,
            limit: 3,
            totalItems: 10,
            totalPages: 4,
            hasNext: false,
            hasPrev: true
        });
    });

    it('should handle empty data array', () => {
        const result = createPagination([], 0);
        
        expect(result).toEqual({
            data: [],
            meta: {
                page: API_CONFIG.PAGINATION.DEFAULT_PAGE,
                limit: API_CONFIG.PAGINATION.DEFAULT_LIMIT,
                totalItems: 0,
                totalPages: 0,
                hasNext: false,
                hasPrev: false
            }
        });
    });

    it('should handle single item', () => {
        const singleItem = [{ id: 1, name: 'Item 1' }];
        const result = createPagination(singleItem, 1);
        
        expect(result).toEqual({
            data: singleItem,
            meta: {
                page: API_CONFIG.PAGINATION.DEFAULT_PAGE,
                limit: API_CONFIG.PAGINATION.DEFAULT_LIMIT,
                totalItems: 1,
                totalPages: 1,
                hasNext: false,
                hasPrev: false
            }
        });
    });
});

================================================
File: src/_core/helper/http-status/common/__tests__/RestHandler.spec.ts
================================================
import { Response } from 'express';
import { CustomRequest } from '@/_core/guard/handle-permission/CustomRequest.interface';
import { HttpStatusCode } from '../HttpStatusCode';
import { StatusCodes } from '../StatusCodes';
import { RestHandler } from '../RestHandler';
import { Link, PaginationResult } from '@/_core/helper/interfaces/rest.interface';

describe('RestHandler', () => {
    let mockReq: Partial<CustomRequest>;
    let mockRes: Partial<Response>;

    beforeEach(() => {
        mockReq = {
            startTime: Date.now(),
            method: 'GET',
            originalUrl: '/test',
            headers: {
                host: 'localhost:3000'
            },
            body: {},
            params: {},
            query: {}
        };
        mockRes = {
            status: jest.fn().mockReturnThis(),
            json: jest.fn(),
            req: mockReq as any
        };
    });

    describe('success', () => {
        it('should return success response with default values', () => {
            RestHandler.success(mockReq as CustomRequest, mockRes as Response, {});

            expect(mockRes.status).toHaveBeenCalledWith(HttpStatusCode.OK);
            expect(mockRes.json).toHaveBeenCalledWith(expect.objectContaining({
                success: true,
                code: HttpStatusCode.OK,
                message: StatusCodes[HttpStatusCode.OK].phrase,
                metadata: expect.objectContaining({
                    timestamp: expect.any(String),
                    statusCode: 'OK',
                    methode: 'GET',
                    path: '/test'
                })
            }));
        });

        it('should include pagination and links when provided', () => {
            const pagination: PaginationResult<unknown> = {
                data: [],
                meta: {
                    page: 1,
                    limit: 10,
                    totalItems: 20,
                    totalPages: 2,
                    hasNext: true,
                    hasPrev: false
                }
            };
             const links: Link = {
                self: '/test',
                next: '/test?page=2',
                first: '/test?page=1',
                last: '/test?page=2' 
            };

            RestHandler.success(mockReq as CustomRequest, mockRes as Response, {
                pagination,
                links
            });

            expect(mockRes.json).toHaveBeenCalledWith(expect.objectContaining({
                metadata: expect.objectContaining({
                    pagination,
                    links
                })
            }));
        });

        it('should include response time when startTime is provided', () => {
            RestHandler.success(mockReq as CustomRequest, mockRes as Response, {});

            expect(mockRes.json).toHaveBeenCalledWith(expect.objectContaining({
                metadata: expect.objectContaining({
                    responseTime: expect.stringMatching(/^\d+ms$/)
                })
            }));
        });
    });

    describe('error', () => {
        it('should return error response with default values', () => {
            RestHandler.error(mockReq as CustomRequest, mockRes as Response, {});

            expect(mockRes.status).toHaveBeenCalledWith(HttpStatusCode.INTERNAL_SERVER_ERROR);
            expect(mockRes.json).toHaveBeenCalledWith(expect.objectContaining({
                success: false,
                code: HttpStatusCode.INTERNAL_SERVER_ERROR,
                message: StatusCodes[HttpStatusCode.INTERNAL_SERVER_ERROR].phrase,
                metadata: expect.objectContaining({
                    timestamp: expect.any(String),
                    statusCode: 'INTERNAL_SERVER_ERROR'
                })
            }));
        });

        it('should include validation errors when provided', () => {
            const errors = [{ field: 'test', message: 'Invalid value' }];

            RestHandler.error(mockReq as CustomRequest, mockRes as Response, {
                errors
            });

            expect(mockRes.json).toHaveBeenCalledWith(expect.objectContaining({
                errors
            }));
        });
    });

    describe('getStatusText', () => {
        it('should return correct status text for valid code', () => {
            const result = RestHandler.getStatusText(HttpStatusCode.OK);
            expect(result).toBe('OK');
        });

        it('should return UNKNOWN_STATUS for invalid code', () => {
            const result = RestHandler.getStatusText(999999);
            expect(result).toBe('UNKNOWN_STATUS');
        });
    });
});

================================================
File: src/_core/helper/http-status/common/api-config.ts
================================================
/**
 * HTTP Methods used in API routes.
 * OPTIONS and HEAD are handled automatically by web frameworks.
 */
const HTTP_METHODS = {
    GET: 'GET',
    POST: 'POST',
    PUT: 'PUT',
    DELETE: 'DELETE',
    PATCH: 'PATCH',
    OPTION: 'OPTIONS',
} as const;

const API_CONFIG = {
    VERSION: '1.0.0',
    PREFIX: '/api/v1',
    TIMEOUT: 30_000, // 30 seconds
    RATE_LIMIT: {
        WINDOW_MS: 15 * 60 * 1000, // 15 minutes
        MAX_REQUESTS: 100, // limit each IP to 100 requests per window
    },
    JSON: {
        LIMIT: '50mb', // Max request body size
    },
    CORS: {
        ORIGINS: {
            DEVELOPMENT: ['http://localhost:3333'],
            PRODUCTION: ['https://myapp.com'], // Update with your production URL
        },
        ALLOWED_HEADERS: ['Authorization', 'Content-Type', 'X-Requires-Auth'],
        METHODS: [
            HTTP_METHODS.GET,
            HTTP_METHODS.POST,
            HTTP_METHODS.PUT,
            HTTP_METHODS.PATCH,
            HTTP_METHODS.DELETE,
            HTTP_METHODS.OPTION,
        ],
        CREDENTIALS: true,
    },
    COMPRESSION: {
        LEVEL: 6,
        THRESHOLD: 1_024, // 1 KB
    },
    PAGINATION: {
        DEFAULT_PAGE: 1,
        DEFAULT_LIMIT: 10,
        MAX_LIMIT: 100,
    },
    CACHE: {
        TTL: 60 * 60, // 1 hour in seconds
        MAX: 1_000, // Max items in cache
    },
    SECURITY: {
        JWT: {
            ACCESS_TOKEN_EXPIRE: '1h',
            REFRESH_TOKEN_EXPIRE: '7d',
            ALGORITHM: 'HS256',
        },
        PASSWORD: {
            SALT_ROUNDS: 10,
            MIN_LENGTH: 8,
        },
    },
    LOGS: {
        DIR: 'logs',
        MAX_SIZE: '10m',
        MAX_FILES: '7d',
    },
} as const;



// Type Inference
export type HttpMethod = keyof typeof HTTP_METHODS;


/**
 * Common HTTP Content-Types used in API requests and responses.
 */
const CONTENT_TYPE = {
    JSON: 'application/json',
    FORM: 'application/x-www-form-urlencoded',
    MULTIPART: 'multipart/form-data',
    TEXT: 'text/plain',
    HTML: 'text/html',
    XML: 'application/xml',
    PDF: 'application/pdf',
} as const;

// Type Inference
export type ContentType = keyof typeof CONTENT_TYPE;


function setResponseType(type: ContentType) {
    return CONTENT_TYPE[type];
}

function handleRequest(method: HttpMethod) {
    switch (method) {
        case HTTP_METHODS.GET:
            console.log('Handling GET request');
            break;
    }
}

export {
    HTTP_METHODS,
    API_CONFIG,
    CONTENT_TYPE,
    setResponseType,
    handleRequest,
};

================================================
File: src/_core/helper/http-status/common/create-pagination.ts
================================================
import { FetchPageResult } from "../../interfaces/FetchPageResult.interface";
import { API_CONFIG } from "./api-config";


/**
 * Creates a paginated result set.
 * @param data - The array of items to include in the current page.
 * @param totalItems - The total number of items available.
 * @param page - The current page number (defaults to API_CONFIG.PAGINATION.DEFAULT_PAGE).
 * @param limit - The number of items per page (defaults to API_CONFIG.PAGINATION.DEFAULT_LIMIT).
 * @returns FetchPageResult<T>
 */
export const createPagination = <T>(
    data: T[],
    totalItems: number,
    page: number = API_CONFIG.PAGINATION.DEFAULT_PAGE,
    limit: number = API_CONFIG.PAGINATION.DEFAULT_LIMIT
): FetchPageResult<T> => {
    // Ensure the limit does not exceed the configured maximum
    const safeLimit = Math.min(limit, API_CONFIG.PAGINATION.MAX_LIMIT);

    // Calculate the total number of pages
    const totalPages = Math.ceil(totalItems / safeLimit);

    return {
        data,
        totalItems,
        count: data.length,
        page,
        totalPages,
        limit: safeLimit,
        hasNext: page < totalPages,
        hasPrev: page > 1,
    };
};


================================================
File: src/_core/helper/http-status/common/HttpStatusCode.ts
================================================
export enum HttpStatusCode {
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.2.1
     *
     * This interim response indicates that everything so far is OK and that the client should continue with the request or ignore it if it is already finished.
     */
    CONTINUE = 100,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.2.2
     *
     * This code is sent in response to an Upgrade request header by the client, and indicates the protocol the server is switching too.
     */
    SWITCHING_PROTOCOLS = 101,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc2518#section-10.1
     *
     * This code indicates that the server has received and is processing the request, but no response is available yet.
     */
    PROCESSING = 102,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.3.1
     *
     * The request has succeeded. The meaning of a success varies depending on the HTTP method:
     * GET: The resource has been fetched and is transmitted in the message body.
     * HEAD: The entity headers are in the message body.
     * POST: The resource describing the result of the action is transmitted in the message body.
     * TRACE: The message body contains the request message as received by the server
     */
    OK = 200,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.3.2
     *
     * The request has succeeded and a new resource has been created as a result of it. This is typically the response sent after a PUT request.
     */
    CREATED = 201,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.3.3
     *
     * The request has been received but not yet acted upon. It is non-committal, meaning that there is no way in HTTP to later send an asynchronous response indicating the outcome of processing the request. It is intended for cases where another process or server handles the request, or for batch processing.
     */
    ACCEPTED = 202,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.3.4
     *
     * This response code means returned meta-information set is not exact set as available from the origin server, but collected from a local or a third party copy. Except this condition, 200 OK response should be preferred instead of this response.
     */
    NON_AUTHORITATIVE_INFORMATION = 203,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.3.5
     *
     * There is no content to send for this request, but the headers may be useful. The user-agent may update its cached headers for this resource with the new ones.
     */
    NO_CONTENT = 204,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.3.6
     *
     * This response code is sent after accomplishing request to tell user agent reset document view which sent this request.
     */
    RESET_CONTENT = 205,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7233#section-4.1
     *
     * This response code is used because of range header sent by the client to separate download into multiple streams.
     */
    PARTIAL_CONTENT = 206,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc2518#section-10.2
     *
     * A Multi-Status response conveys information about multiple resources in situations where multiple status codes might be appropriate.
     */
    MULTI_STATUS = 207,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.4.1
     *
     * The request has more than one possible responses. User-agent or user should choose one of them. There is no standardized way to choose one of the responses.
     */
	ALREADY_REPORTED = 208,
	/**
	 * https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/208
	 * 
	 * The HTTP 208 Already Reported successful response status code is used in a 207 Multi-Status response to save space and avoid conflicts. This response is used exclusively in the context of Web Distributed Authoring and Versioning (WebDAV).
	 *
	 * If the same resource is requested several times (for example, as part of a collection) with different paths, only the first one is reported with 200. Responses for all other bindings will report with this 208 status code, so no conflicts are created and the response stays shorter.
	 *
	 * Note = The ability to bind a resource to several paths is an extension to the WebDAV protocol (it may be received by web applications accessing a WebDAV server). Browsers accessing web pages will never encounter this status code.
	 * 
	 * */
	IM_USED = 226,
	/**	
	 * https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/226
	 * 
	 * */
    MULTIPLE_CHOICES = 300,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.4.2
     *
     * This response code means that URI of requested resource has been changed. Probably, new URI would be given in the response.
     */
    MOVED_PERMANENTLY = 301,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.4.3
     *
     * This response code means that URI of requested resource has been changed temporarily. New changes in the URI might be made in the future. Therefore, this same URI should be used by the client in future requests.
     */
    MOVED_TEMPORARILY = 302,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.4.4
     *
     * Server sent this response to directing client to get requested resource to another URI with an GET request.
     */
    SEE_OTHER = 303,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7232#section-4.1
     *
     * This is used for caching purposes. It is telling to client that response has not been modified. So, client can continue to use same cached version of response.
     */
    NOT_MODIFIED = 304,
    /**
     * @deprecated
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.4.6
     *
     * Was defined in a previous version of the HTTP specification to indicate that a requested response must be accessed by a proxy. It has been deprecated due to security concerns regarding in-band configuration of a proxy.
     */
    USE_PROXY = 305,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.4.7
     *
     * Server sent this response to directing client to get requested resource to another URI with same method that used prior request. This has the same semantic than the 302 Found HTTP response code, with the exception that the user agent must not change the HTTP method used: if a POST was used in the first request, a POST must be used in the second request.
     */
    TEMPORARY_REDIRECT = 307,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7538#section-3
     *
     * This means that the resource is now permanently located at another URI, specified by the Location: HTTP Response header. This has the same semantics as the 301 Moved Permanently HTTP response code, with the exception that the user agent must not change the HTTP method used: if a POST was used in the first request, a POST must be used in the second request.
     */
    PERMANENT_REDIRECT = 308,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.5.1
     *
     * This response means that server could not understand the request due to invalid syntax.
     */
    BAD_REQUEST = 400,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7235#section-3.1
     *
     * Although the HTTP standard specifies "unauthorized", semantically this response means "unauthenticated". That is, the client must authenticate itself to get the requested response.
     */
    UNAUTHORIZED = 401,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.5.2
     *
     * This response code is reserved for future use. Initial aim for creating this code was using it for digital payment systems however this is not used currently.
     */
    PAYMENT_REQUIRED = 402,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.5.3
     *
     * The client does not have access rights to the content, i.e. they are unauthorized, so server is rejecting to give proper response. Unlike 401, the client's identity is known to the server.
     */
    FORBIDDEN = 403,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.5.4
     *
     * The server can not find requested resource. In the browser, this means the URL is not recognized. In an API, this can also mean that the endpoint is valid but the resource itself does not exist. Servers may also send this response instead of 403 to hide the existence of a resource from an unauthorized client. This response code is probably the most famous one due to its frequent occurence on the web.
     */
    NOT_FOUND = 404,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.5.5
     *
     * The request method is known by the server but has been disabled and cannot be used. For example, an API may forbid DELETE-ing a resource. The two mandatory methods, GET and HEAD, must never be disabled and should not return this error code.
     */
    METHOD_NOT_ALLOWED = 405,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.5.6
     *
     * This response is sent when the web server, after performing server-driven content negotiation, doesn't find any content following the criteria given by the user agent.
     */
    NOT_ACCEPTABLE = 406,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7235#section-3.2
     *
     * This is similar to 401 but authentication is needed to be done by a proxy.
     */
    PROXY_AUTHENTICATION_REQUIRED = 407,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.5.7
     *
     * This response is sent on an idle connection by some servers, even without any previous request by the client. It means that the server would like to shut down this unused connection. This response is used much more since some browsers, like Chrome, Firefox 27+, or IE9, use HTTP pre-connection mechanisms to speed up surfing. Also note that some servers merely shut down the connection without sending this message.
     */
    REQUEST_TIMEOUT = 408,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.5.8
     *
     * This response is sent when a request conflicts with the current state of the server.
     */
    CONFLICT = 409,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.5.9
     *
     * This response would be sent when the requested content has been permenantly deleted from server, with no forwarding address. Clients are expected to remove their caches and links to the resource. The HTTP specification intends this status code to be used for "limited-time, promotional services". APIs should not feel compelled to indicate resources that have been deleted with this status code.
     */
    GONE = 410,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.5.10
     *
     * The server rejected the request because the Content-Length header field is not defined and the server requires it.
     */
    LENGTH_REQUIRED = 411,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7232#section-4.2
     *
     * The client has indicated preconditions in its headers which the server does not meet.
     */
    PRECONDITION_FAILED = 412,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.5.11
     *
     * Request entity is larger than limits defined by server; the server might close the connection or return an Retry-After header field.
     */
    REQUEST_TOO_LONG = 413,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.5.12
     *
     * The URI requested by the client is longer than the server is willing to interpret.
     */
    REQUEST_URI_TOO_LONG = 414,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.5.13
     *
     * The media format of the requested data is not supported by the server, so the server is rejecting the request.
     */
    UNSUPPORTED_MEDIA_TYPE = 415,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7233#section-4.4
     *
     * The range specified by the Range header field in the request can't be fulfilled; it's possible that the range is outside the size of the target URI's data.
     */
    REQUESTED_RANGE_NOT_SATISFIABLE = 416,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.5.14
     *
     * This response code means the expectation indicated by the Expect request header field can't be met by the server.
     */
    EXPECTATION_FAILED = 417,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc2324#section-2.3.2
     *
     * Any attempt to brew coffee with a teapot should result in the error code "418 I'm a teapot". The resulting entity body MAY be short and stout.
     */
    IM_A_TEAPOT = 418,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc2518#section-10.6
     *
     * The 507 (Insufficient Storage) status code means the method could not be performed on the resource because the server is unable to store the representation needed to successfully complete the request. This condition is considered to be temporary. If the request which received this status code was the result of a user action, the request MUST NOT be repeated until it is requested by a separate user action.
     */
    INSUFFICIENT_SPACE_ON_RESOURCE = 419,
    /**
     * @deprecated
     * Official Documentation @ https://tools.ietf.org/rfcdiff?difftype=--hwdiff&url2=draft-ietf-webdav-protocol-06.txt
     *
     * A deprecated response used by the Spring Framework when a method has failed.
     */
    METHOD_FAILURE = 420,
    /**
     * Official Documentation @ https://datatracker.ietf.org/doc/html/rfc7540#section-9.1.2
     *
     * Defined in the specification of HTTP/2 to indicate that a server is not able to produce a response for the combination of scheme and authority that are included in the request URI.
     */
    MISDIRECTED_REQUEST = 421,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc2518#section-10.3
     *
     * The request was well-formed but was unable to be followed due to semantic errors.
     */
    UNPROCESSABLE_ENTITY = 422,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc2518#section-10.4
     *
     * The resource that is being accessed is locked.
     */
    LOCKED = 423,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc2518#section-10.5
     *
     * The request failed due to failure of a previous request.
     */
    FAILED_DEPENDENCY = 424,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc6585#section-3
     *
     * The origin server requires the request to be conditional. Intended to prevent the 'lost update' problem, where a client GETs a resource's state, modifies it, and PUTs it back to the server, when meanwhile a third party has modified the state on the server, leading to a conflict.
     */
    PRECONDITION_REQUIRED = 428,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc6585#section-4
     *
     * The user has sent too many requests in a given amount of time ("rate limiting").
     */
    TOO_MANY_REQUESTS = 429,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc6585#section-5
     *
     * The server is unwilling to process the request because its header fields are too large. The request MAY be resubmitted after reducing the size of the request header fields.
     */
    REQUEST_HEADER_FIELDS_TOO_LARGE = 431,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7725
     *
     * The user-agent requested a resource that cannot legally be provided, such as a web page censored by a government.
     */
    UNAVAILABLE_FOR_LEGAL_REASONS = 451,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.6.1
     *
     * The server encountered an unexpected condition that prevented it from fulfilling the request.
     */
    INTERNAL_SERVER_ERROR = 500,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.6.2
     *
     * The request method is not supported by the server and cannot be handled. The only methods that servers are required to support (and therefore that must not return this code) are GET and HEAD.
     */
    NOT_IMPLEMENTED = 501,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.6.3
     *
     * This error response means that the server, while working as a gateway to get a response needed to handle the request, got an invalid response.
     */
    BAD_GATEWAY = 502,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.6.4
     *
     * The server is not ready to handle the request. Common causes are a server that is down for maintenance or that is overloaded. Note that together with this response, a user-friendly page explaining the problem should be sent. This responses should be used for temporary conditions and the Retry-After: HTTP header should, if possible, contain the estimated time before the recovery of the service. The webmaster must also take care about the caching-related headers that are sent along with this response, as these temporary condition responses should usually not be cached.
     */
    SERVICE_UNAVAILABLE = 503,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.6.5
     *
     * This error response is given when the server is acting as a gateway and cannot get a response in time.
     */
    GATEWAY_TIMEOUT = 504,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.6.6
     *
     * The HTTP version used in the request is not supported by the server.
     */
    HTTP_VERSION_NOT_SUPPORTED = 505,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc2518#section-10.6
     *
     * The server has an internal configuration error: the chosen variant resource is configured to engage in transparent content negotiation itself, and is therefore not a proper end point in the negotiation process.
     */
    INSUFFICIENT_STORAGE = 507,
    /**
     * Official Documentation @ https://tools.ietf.org/html/rfc6585#section-6
     *
     * The 511 status code indicates that the client needs to authenticate to gain network access.
     */
    NETWORK_AUTHENTICATION_REQUIRED = 511
}

================================================
File: src/_core/helper/http-status/common/RestHandler.ts
================================================
// src/_core/utils/response.handler.ts
import { Response } from 'express';
import { PaginationResult, RestResponse, ValidationError } from '../../interfaces/rest.interface';
import { logResponse } from '../response-log';
import { HttpStatusCode } from './HttpStatusCode';
import { StatusCodes } from './StatusCodes';
import { HATEOASLinks } from 'express-route-tracker';
import { CustomRequest } from '../../interfaces/CustomRequest.interface';
import { HttpMethod } from './api-config';

export class RestHandler {
    static success<T>(req: CustomRequest<T>, res: Response, {
        code = HttpStatusCode.OK,
        data,     
        message,
        pagination,
        links,
    }: {
        data?: Partial<T> | Partial<T>[];
        message?: string;
        code?: HttpStatusCode;
        pagination?: PaginationResult<T>;
        links?: HATEOASLinks;
        startTime?: number;
        }): Response {
        const response: RestResponse<T> = {
            success: true,
            code,
            message :  message || StatusCodes[code].phrase,            
            data,
            metadata: {                
                timestamp: new Date().toISOString(),
                statusCode: this.getStatusText(code),
                methode: res.req.method as HttpMethod,
                path: res.req.originalUrl,
                ...(pagination && { pagination }),
                ...(links && { links }),
                description: StatusCodes[code].description,
                documentation: StatusCodes[code].documentation,
            },
        };
        if (req.startTime) {
            response.metadata.responseTime = `${Date.now() - req.startTime}ms`;
        }
        return res.status(code).json(response);
    }

    static error<T>(req: CustomRequest<T>, res: Response, {
        code = HttpStatusCode.INTERNAL_SERVER_ERROR,
        message = StatusCodes[HttpStatusCode.INTERNAL_SERVER_ERROR].phrase,
        errors,
    }: {
        code?: HttpStatusCode;
        message?: string;
        errors?: ValidationError[];
        startTime?: number;
        }): Response {      
        const response: RestResponse = {
            success: false,
            code,
            message,
            errors,
            metadata: {
                timestamp: new Date().toISOString(),
                statusCode: this.getStatusText(code),
                description: StatusCodes[code].description,
                documentation: StatusCodes[code].documentation,
            },            
        };
        if (req.startTime) {
            response.metadata.responseTime = `${Date.now() - req.startTime}ms`;
        }
        logResponse(req, JSON.stringify(response, null, 2));
        return res.status(code).json(response);
    }

    static getStatusText(code: number): string {
        return Object.entries(HttpStatusCode)
            .find(([_, value]) => value === code)?.[0] || 'UNKNOWN_STATUS';
    }
}

================================================
File: src/_core/helper/http-status/common/StatusCodes.ts
================================================
import { HttpStatusCode } from './HttpStatusCode';

export const StatusCodes = {
    [HttpStatusCode.ACCEPTED]: { 
        code: HttpStatusCode.ACCEPTED, // 202
        phrase: "Accepted",
        description: "The request has been accepted for processing, but the processing has not been completed.",
        documentation: "https://tools.ietf.org/html/rfc7231#section-6.3.3"
    },
    [HttpStatusCode.BAD_GATEWAY]: { 
        code: HttpStatusCode.BAD_GATEWAY, // 502
        phrase: "Bad Gateway",
        description: "The server, while acting as a gateway, received an invalid response from the upstream server.",
        documentation: "https://tools.ietf.org/html/rfc7231#section-6.6.3"
    },
    [HttpStatusCode.BAD_REQUEST]: { 
        code: HttpStatusCode.BAD_REQUEST, // 400
        phrase: "Bad Request",
        description: "The server could not understand the request due to invalid syntax.",
        documentation: "https://tools.ietf.org/html/rfc7231#section-6.5.1"
    },
    [HttpStatusCode.CONFLICT]: {
        code: HttpStatusCode.CONFLICT,  // 409
        phrase: "Conflict",
        description: "The request conflicts with the current state of the resource.",
        documentation: "https://tools.ietf.org/html/rfc7231#section-6.5.8"
    },
    [HttpStatusCode.CONTINUE]: {
        code: HttpStatusCode.CONTINUE, // 100
        phrase: "Continue",
        description: "Indicates that the initial part of a request has been received and the client should continue.",
        documentation: "https://tools.ietf.org/html/rfc7231#section-6.2.1"
    },
    [HttpStatusCode.CREATED]: { 
        code: HttpStatusCode.CREATED, // 201
        phrase: "Created",
        description: "The request has succeeded and a new resource has been created as a result.",
        documentation: "https://tools.ietf.org/html/rfc7231#section-6.3.2"
    },
    [HttpStatusCode.EXPECTATION_FAILED]: { 
        code: HttpStatusCode.EXPECTATION_FAILED, // 417
        phrase: "Expectation Failed",
        description: "The expectation given in the Expect header field could not be met by the server.",
        documentation: "https://tools.ietf.org/html/rfc7231#section-6.5.14"
    },
    [HttpStatusCode.FAILED_DEPENDENCY]: {
        code: HttpStatusCode.FAILED_DEPENDENCY,  // 424
        phrase: "Failed Dependency",
        description: "The request failed due to failure of a previous request.",
        documentation: "https://tools.ietf.org/html/rfc2518#section-10.5"
    },
    [HttpStatusCode.FORBIDDEN]: {
        code: HttpStatusCode.FORBIDDEN,  // 403
        phrase: "Forbidden",
        description: "The server understands the request, but it refuses to authorize it.",
        documentation: "https://tools.ietf.org/html/rfc7231#section-6.5.3"
    },
    [HttpStatusCode.GATEWAY_TIMEOUT]: {
        code: HttpStatusCode.GATEWAY_TIMEOUT,  // 504
        phrase: "Gateway Timeout",
        description: "The server, while acting as a gateway, did not get a response in time.",
        documentation: "https://tools.ietf.org/html/rfc7231#section-6.6.5"
    },
    [HttpStatusCode.GONE]: {
        code: HttpStatusCode.GONE,  // 410
        phrase: "Gone",
        description: "The requested resource is no longer available at the server and no forwarding address is known.",
        documentation: "https://tools.ietf.org/html/rfc7231#section-6.5.9"
    },
    [HttpStatusCode.HTTP_VERSION_NOT_SUPPORTED]: {
        code: HttpStatusCode.HTTP_VERSION_NOT_SUPPORTED,  // 505
        phrase: "HTTP Version Not Supported",
        description: "The server does not support the HTTP protocol version used in the request.",
        documentation: "https://tools.ietf.org/html/rfc7231#section-6.6.6"
    },
    [HttpStatusCode.IM_A_TEAPOT]: {
        code: HttpStatusCode.IM_A_TEAPOT,  // 418
        phrase: "I'm a teapot",
        description: "Any attempt to brew coffee with a teapot should result in this error.",
        documentation: "https://tools.ietf.org/html/rfc2324#section-2.3.2"
    },
    [HttpStatusCode.INSUFFICIENT_SPACE_ON_RESOURCE]: {
        code: HttpStatusCode.INSUFFICIENT_SPACE_ON_RESOURCE,  // 419
        phrase: "Insufficient Space on Resource",
        description: "The server cannot store the representation needed to complete the request.",
        documentation: "https://tools.ietf.org/html/rfc2518#section-10.6"
    },
    [HttpStatusCode.INSUFFICIENT_STORAGE]: {
        code: HttpStatusCode.INSUFFICIENT_STORAGE,  // 507
        phrase: "Insufficient Storage",
        description: "The server does not have enough storage space to complete the request.",
        documentation: "https://tools.ietf.org/html/rfc2518#section-10.6"
    },
    [HttpStatusCode.INTERNAL_SERVER_ERROR]: {
        code: HttpStatusCode.INTERNAL_SERVER_ERROR,  // 500
        phrase: "Internal Server Error",
        description: "The server encountered an unexpected condition that prevented it from fulfilling the request.",
        documentation: "https://tools.ietf.org/html/rfc7231#section-6.6.1"
    },
    [HttpStatusCode.LENGTH_REQUIRED]: {
        code: HttpStatusCode.LENGTH_REQUIRED,  // 411
        phrase: "Length Required",
        description: "The server refuses to accept the request without a defined Content-Length.",
        documentation: "https://tools.ietf.org/html/rfc7231#section-6.5.10"
    },
    [HttpStatusCode.LOCKED]: {
        code: HttpStatusCode.LOCKED,  // 423
        phrase: "Locked",
        description: "The resource that is being accessed is locked.",
        documentation: "https://tools.ietf.org/html/rfc2518#section-10.4"
    },
    [HttpStatusCode.METHOD_FAILURE]: {
        code: HttpStatusCode.METHOD_FAILURE,  // 424
        phrase: "Method Failure",
        description: "A deprecated response indicating a method failure, primarily used by the Spring Framework.",
        documentation: "https://tools.ietf.org/rfcdiff?difftype=--hwdiff&url2=draft-ietf-webdav-protocol-06.txt"
    },
    [HttpStatusCode.METHOD_NOT_ALLOWED]: {
        code: HttpStatusCode.METHOD_NOT_ALLOWED,  // 405
        phrase: "Method Not Allowed",
        description: "The request method is known by the server but has been disabled and cannot be used.",
        documentation: "https://tools.ietf.org/html/rfc7231#section-6.5.5"
    },
    [HttpStatusCode.MOVED_PERMANENTLY]: {
        code: HttpStatusCode.MOVED_PERMANENTLY,  // 301
        phrase: "Moved Permanently",
        description: "The requested resource has been permanently moved to a new URI.",
        documentation: "https://tools.ietf.org/html/rfc7231#section-6.4.2"
    },
    [HttpStatusCode.MOVED_TEMPORARILY]: {
        code: HttpStatusCode.MOVED_TEMPORARILY,  // 302
        phrase: "Moved Temporarily",
        description: "The resource has been temporarily moved to a different URI.",
        documentation: "https://tools.ietf.org/html/rfc7231#section-6.4.3"
    },
    [HttpStatusCode.MULTI_STATUS]: {
        code: HttpStatusCode.MULTI_STATUS,  // 207
        phrase: "Multi-Status",
        description: "Conveys information about multiple resources in situations where multiple status codes might be appropriate.",
        documentation: "https://tools.ietf.org/html/rfc2518#section-10.2"
    },
    [HttpStatusCode.ALREADY_REPORTED]: {
        code: HttpStatusCode.ALREADY_REPORTED, // 208
        phrase: "Already Reported",
        description: "The same resource was requested multiple times and is already reported.",
        documentation: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/208"
    },
    [HttpStatusCode.IM_USED]: {
        code: HttpStatusCode.IM_USED,  // 226
        phrase: "IM Used",
        description: "The server has fulfilled a request for the resource, and the response represents the result of one or more instance manipulations applied to the current instance.",
        documentation: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/226"
    },
    [HttpStatusCode.MULTIPLE_CHOICES]: {
        code: HttpStatusCode.MULTIPLE_CHOICES,  // 300
        phrase: "Multiple Choices",
        description: "The request has more than one possible response. The user-agent or user should choose one of them.",
        documentation: "https://tools.ietf.org/html/rfc7231#section-6.4.1"
    },
    [HttpStatusCode.NETWORK_AUTHENTICATION_REQUIRED]: {
        code: HttpStatusCode.NETWORK_AUTHENTICATION_REQUIRED, // 511
        phrase: "Network Authentication Required",
        description: "The client needs to authenticate to gain network access.",
        documentation: "https://tools.ietf.org/html/rfc6585#section-6"
    },
    [HttpStatusCode.NO_CONTENT]: {
        code: HttpStatusCode.NO_CONTENT,  // 204
        phrase: "No Content",
        description: "The server successfully processed the request, but is not returning any content.",
        documentation: "https://tools.ietf.org/html/rfc7231#section-6.3.5"
    },
    [HttpStatusCode.NON_AUTHORITATIVE_INFORMATION]: {
        code: HttpStatusCode.NON_AUTHORITATIVE_INFORMATION,  // 203
        phrase: "Non-Authoritative Information",
        description: "The returned meta-information is not exactly the same as available from the origin server.",
        documentation: "https://tools.ietf.org/html/rfc7231#section-6.3.4"
    },
    [HttpStatusCode.NOT_ACCEPTABLE]: {
        code: HttpStatusCode.NOT_ACCEPTABLE,  // 406
        phrase: "Not Acceptable",
        description: "The server cannot produce a response matching the list of acceptable values defined in the request's proactive content negotiation headers.",
        documentation: "https://tools.ietf.org/html/rfc7231#section-6.5.6"
    },
    [HttpStatusCode.NOT_FOUND]: {
        code: HttpStatusCode.NOT_FOUND,  // 404
        phrase: "Not Found",
        description: "The server cannot find the requested resource.",
        documentation: "https://tools.ietf.org/html/rfc7231#section-6.5.4"
    },
    [HttpStatusCode.NOT_IMPLEMENTED]: {
        code: HttpStatusCode.NOT_IMPLEMENTED,  // 501
        phrase: "Not Implemented",
        description: "The request method is not supported by the server and cannot be handled.",
        documentation: "https://tools.ietf.org/html/rfc7231#section-6.6.2"
    },
    [HttpStatusCode.NOT_MODIFIED]: {
        code: HttpStatusCode.NOT_MODIFIED,  // 304
        phrase: "Not Modified",
        description: "Indicates that the resource has not been modified since the last request.",
        documentation: "https://tools.ietf.org/html/rfc7232#section-4.1"
    },
    [HttpStatusCode.OK]: {
        code: HttpStatusCode.OK,  // 200
        phrase: "OK",
        description: "The request has succeeded.",
        documentation: "https://tools.ietf.org/html/rfc7231#section-6.3.1"
    },
    [HttpStatusCode.PARTIAL_CONTENT]: {
        code: HttpStatusCode.PARTIAL_CONTENT,  // 206
        phrase: "Partial Content",
        description: "The server successfully processed a partial GET request.",
        documentation: "https://tools.ietf.org/html/rfc7233#section-4.1"
    },
    [HttpStatusCode.PAYMENT_REQUIRED]: {
        code: HttpStatusCode.PAYMENT_REQUIRED,  // 402
        phrase: "Payment Required",
        description: "Reserved for future use. Intended for digital payment systems.",
        documentation: "https://tools.ietf.org/html/rfc7231#section-6.5.2"
    },
    [HttpStatusCode.PERMANENT_REDIRECT]: {
        code: HttpStatusCode.PERMANENT_REDIRECT,  // 308
        phrase: "Permanent Redirect",
        description: "The resource has been permanently moved to a new URI.",
        documentation: "https://tools.ietf.org/html/rfc7538#section-3"
    },
    [HttpStatusCode.PRECONDITION_FAILED]: {
        code: HttpStatusCode.PRECONDITION_FAILED,  // 412
        phrase: "Precondition Failed",
        description: "The server does not meet one of the preconditions specified by the client.",
        documentation: "https://tools.ietf.org/html/rfc7232#section-4.2"
    },
    [HttpStatusCode.PRECONDITION_REQUIRED]: {
        code: HttpStatusCode.PRECONDITION_REQUIRED,  // 428
        phrase: "Precondition Required",
        description: "The server requires the request to be conditional to prevent conflicts.",
        documentation: "https://tools.ietf.org/html/rfc6585#section-3"
    },
    [HttpStatusCode.PROCESSING]: {
        code: HttpStatusCode.PROCESSING,  // 102
        phrase: "Processing",
        description: "The server has received and is processing the request, but no response is available yet.",
        documentation: "https://tools.ietf.org/html/rfc2518#section-10.1"
    },
    [HttpStatusCode.PROXY_AUTHENTICATION_REQUIRED]: {
        code: HttpStatusCode.PROXY_AUTHENTICATION_REQUIRED,  // 407
        phrase: "Proxy Authentication Required",
        description: "Authentication is required to access the resource through a proxy.",
        documentation: "https://tools.ietf.org/html/rfc7235#section-3.2"
    },
    [HttpStatusCode.REQUEST_HEADER_FIELDS_TOO_LARGE]: {
        code: HttpStatusCode.REQUEST_HEADER_FIELDS_TOO_LARGE,  // 431
        phrase: "Request Header Fields Too Large",
        description: "The request header fields are too large for the server to process.",
        documentation: "https://tools.ietf.org/html/rfc6585#section-5"
    },
    [HttpStatusCode.REQUEST_TIMEOUT]: {
        code: HttpStatusCode.REQUEST_TIMEOUT,  // 408
        phrase: "Request Timeout",
        description: "The server timed out waiting for the request.",
        documentation: "https://tools.ietf.org/html/rfc7231#section-6.5.7"
    },
    [HttpStatusCode.REQUEST_TOO_LONG]: {
        code: HttpStatusCode.REQUEST_TOO_LONG,  // 413
        phrase: "Request Entity Too Large",
        description: "The request payload is larger than the server is willing or able to process.",
        documentation: "https://tools.ietf.org/html/rfc7231#section-6.5.11"
    },
    [HttpStatusCode.REQUEST_URI_TOO_LONG]: {
        code: HttpStatusCode.REQUEST_URI_TOO_LONG,  // 414
        phrase: "Request-URI Too Long",
        description: "The URI provided in the request is too long for the server to interpret.",
        documentation: "https://tools.ietf.org/html/rfc7231#section-6.5.12"
    },
    [HttpStatusCode.REQUESTED_RANGE_NOT_SATISFIABLE]: {
        code: HttpStatusCode.REQUESTED_RANGE_NOT_SATISFIABLE,  // 416
        phrase: "Requested Range Not Satisfiable",
        description: "The requested range specified in the Range header field cannot be fulfilled.",
        documentation: "https://tools.ietf.org/html/rfc7233#section-4.4"
    },
    [HttpStatusCode.RESET_CONTENT]: {
        code: HttpStatusCode.RESET_CONTENT,  // 205
        phrase: "Reset Content",
        description: "Indicates that the client should reset the document view.",
        documentation: "https://tools.ietf.org/html/rfc7231#section-6.3.6"
    },
    [HttpStatusCode.SEE_OTHER]: {
        code: HttpStatusCode.SEE_OTHER,  // 303
        phrase: "See Other",
        description: "The resource is located at a different URI, and the client should retrieve it using a GET request.",
        documentation: "https://tools.ietf.org/html/rfc7231#section-6.4.4"
    },
    [HttpStatusCode.SERVICE_UNAVAILABLE]: {
        code: HttpStatusCode.SERVICE_UNAVAILABLE,  // 503
        phrase: "Service Unavailable",
        description: "The server is temporarily unable to handle the request, often due to maintenance or overload.",
        documentation: "https://tools.ietf.org/html/rfc7231#section-6.6.4"
    },
    [HttpStatusCode.SWITCHING_PROTOCOLS]: {
        code: HttpStatusCode.SWITCHING_PROTOCOLS,  // 101
        phrase: "Switching Protocols",
        description: "The server is switching protocols as requested by the client via the Upgrade header.",
        documentation: "https://tools.ietf.org/html/rfc7231#section-6.2.2"
    },
    [HttpStatusCode.TEMPORARY_REDIRECT]: {
        code: HttpStatusCode.TEMPORARY_REDIRECT,  // 307
        phrase: "Temporary Redirect",
        description: "The resource is temporarily located at a different URI, and the same request method should be used.",
        documentation: "https://tools.ietf.org/html/rfc7231#section-6.4.7"
    },
    [HttpStatusCode.TOO_MANY_REQUESTS]: {
        code: HttpStatusCode.TOO_MANY_REQUESTS,  // 429
        phrase: "Too Many Requests",
        description: "The client has sent too many requests in a given period.",
        documentation: "https://tools.ietf.org/html/rfc6585#section-4"
    },
    [HttpStatusCode.UNAUTHORIZED]: {
        code: HttpStatusCode.UNAUTHORIZED, // 401
        phrase: "Unauthorized",
        description: "The client must authenticate itself to get the requested response.",
        documentation: "https://tools.ietf.org/html/rfc7235#section-3.1"
    },
    [HttpStatusCode.UNAVAILABLE_FOR_LEGAL_REASONS]: {
        code: HttpStatusCode.UNAVAILABLE_FOR_LEGAL_REASONS,  // 451
        phrase: "Unavailable For Legal Reasons",
        description: "The requested resource cannot legally be provided, often due to censorship or government restrictions.",
        documentation: "https://tools.ietf.org/html/rfc7725"
    },
    [HttpStatusCode.UNPROCESSABLE_ENTITY]: {
        code: HttpStatusCode.UNPROCESSABLE_ENTITY, // 422
        phrase: "Unprocessable Entity",
        description: "The request was well-formed but was unable to be followed due to semantic errors.",
        documentation: "https://tools.ietf.org/html/rfc2518#section-10.3"
    },
    [HttpStatusCode.UNSUPPORTED_MEDIA_TYPE]: {
        code: HttpStatusCode.UNSUPPORTED_MEDIA_TYPE,  // 415
        phrase: "Unsupported Media Type",
        description: "The server does not support the media format of the requested data.",
        documentation: "https://tools.ietf.org/html/rfc7231#section-6.5.13"
    },
    [HttpStatusCode.USE_PROXY]: {
        code: HttpStatusCode.USE_PROXY,  // 305
        phrase: "Use Proxy",
        description: "This response code is deprecated and indicates that a requested response must be accessed by a proxy.",
        documentation: "https://tools.ietf.org/html/rfc7231#section-6.4.6"
    },
    [HttpStatusCode.MISDIRECTED_REQUEST]: {
        code: HttpStatusCode.MISDIRECTED_REQUEST,  // 421
        phrase: "Misdirected Request",
        description: "The server cannot produce a response for the combination of scheme and authority included in the request URI.",
        documentation: "https://datatracker.ietf.org/doc/html/rfc7540#section-9.1.2"
    }    
};

================================================
File: src/_core/helper/http-status/error/index.ts
================================================
import { NextFunction, Response } from 'express';
import { HttpStatusCode } from '../common/HttpStatusCode';
import { StatusCodes } from '../common/StatusCodes';
import { RestHandler } from '../common/RestHandler';

export class ErrorResponse {
    success: boolean;
    message: string;
    error?: any;
    status: HttpStatusCode;
    metadata: any;
    options: any;
    errors?: Array<{ field: string; message: string; code?: string }>;

    constructor({
        message,
        error = {},
        status = HttpStatusCode.INTERNAL_SERVER_ERROR,
        reasonPhrase = StatusCodes[status].phrase,
		errors,
        options = {},
    }: {
        message?: string;
        error?: any;
        status?: HttpStatusCode;
        reasonPhrase?: string;
        metadata?: any;
		errors?: Array<{ field: string; message: string; code?: string }>;
        options?: any;
    }) {
        this.success = false;
        this.message = message || reasonPhrase;
        this.error = error;
        this.status = status;
		this.errors = errors;
        this.metadata = this.formatMetadata(this.metadata);
        this.options = options;
    }

    private formatMetadata(metadata: any) {
        return {
            ...metadata,
        };
    }

    setStatus(status: number) {
        this.status = status;
        this.metadata.code = status;
        this.metadata.status = RestHandler.getStatusText(status);
        return this;
    }

    setMessage(message: string) {
        this.message = message;
        return this;
    }

    setMetadata(metadata: any) {
        this.metadata = { ...this.metadata, ...metadata };
        return this;
    }

    setOptions(options: any) {
        this.options = options;
        return this;
    }

    setResponseTime(startTime?: number) {
        const responseTime = startTime ? `${Date.now() - startTime}ms` : '0ms';
        this.metadata.responseTime = responseTime;
        return this;
    }

    setHeader(headers: Record<string, string>) {
        this.options.headers = { ...this.options.headers, ...headers };
        return this;
    }

    setError(error: any) {
        this.error = error;
        return this;
    }

    send(res: Response, next?: NextFunction) {
        try {
            this.preSendHooks();

            if (res.locals?.startTime) {
                this.setResponseTime(res.locals.startTime);
            }

            if (!res.headersSent) {
                const response = this.formatResponse();
                res.status(this.status).json(response);
            } else {
                console.warn('Attempted to send response after headers were already sent.');
            }

            this.postSendHooks();
        } catch (error) {
            console.error('Error sending response:', error);
            if (next) {
                next(error);
            } else {
                throw error;
            }
        }
    }

    private preSendHooks() {
        this.metadata.timestamp = new Date().toISOString();
    }

    private formatResponse() {
        const response = {
            success: this.success,
            message: this.message,
            error: this.error,
            metadata: {
                ...this.metadata,
                code: this.status,
                status: RestHandler.getStatusText(this.status),
            },
        };

        if (Object.keys(this.options).length > 0) {
            Object.assign(response, { options: this.options });
        }

        return response;
    }

    private postSendHooks() {
        console.error(`Error response sent with status: ${this.status}`);
    }
}

class BadRequestError extends ErrorResponse {
    constructor(params: any = {}) {
        super({
            ...params,
            status: params.status || HttpStatusCode.BAD_REQUEST,
        });
    }
}

class UnauthorizedError extends ErrorResponse {
    constructor(params: any = {}) {
        super({
            ...params,
            status: params.status || HttpStatusCode.UNAUTHORIZED,
        });
    }
}

class ForbiddenError extends ErrorResponse {
    constructor(params: any = {}) {
        super({
            ...params,
            status: params.status || HttpStatusCode.FORBIDDEN,
        });
    }
}

class NotFoundError extends ErrorResponse {
    constructor(params: any = {}) {
        super({
            ...params,
            status: params.status || HttpStatusCode.NOT_FOUND,
        });
    }
}

class ConflictError extends ErrorResponse {
    constructor(params: any = {}) {
        super({
            ...params,
            status: params.status || HttpStatusCode.CONFLICT,
        });
    }
}

class UnprocessableEntityError extends ErrorResponse {
    constructor(params: any = {}) {
        super({
            ...params,
            status: params.status || HttpStatusCode.UNPROCESSABLE_ENTITY,
        });
    }
}


class InternalServerError extends ErrorResponse {
    constructor(params: any = {}) {
        super({
            ...params,
            status: params.status || HttpStatusCode.INTERNAL_SERVER_ERROR,
        });
    }
}

class NotImplementedError extends ErrorResponse {
    constructor(params: any = {}) {
        super({
            ...params,
            status: params.status || HttpStatusCode.NOT_IMPLEMENTED,
        });
    }
}

class BadGatewayError extends ErrorResponse {
    constructor(params: any = {}) {
        super({
            ...params,
            status: params.status || HttpStatusCode.BAD_GATEWAY,
        });
    }
}

class ServiceUnavailableError extends ErrorResponse {
    constructor(params: any = {}) {
        super({
            ...params,
            status: params.status || HttpStatusCode.SERVICE_UNAVAILABLE,
        });
    }
}

class GatewayTimeoutError extends ErrorResponse {
    constructor(params: any = {}) {
        super({
            ...params,
            status: params.status || HttpStatusCode.GATEWAY_TIMEOUT,
        });
    }
}

class HttpVersionNotSupportedError extends ErrorResponse {
    constructor(params: any = {}) {
        super({
            ...params,
            status: params.status || HttpStatusCode.HTTP_VERSION_NOT_SUPPORTED,
        });
    }
}

class NetworkAuthenticationRequiredError extends ErrorResponse {
    constructor(params: any = {}) {
        super({
            ...params,
            status: params.status || HttpStatusCode.NETWORK_AUTHENTICATION_REQUIRED,
        });
    }
}

class ValidationError extends ErrorResponse {
    constructor(params: any = {}) {
        super({
            ...params,
            status: params.status || HttpStatusCode.BAD_REQUEST,
        });
    }
}

class PaymentRequiredError extends ErrorResponse {
    constructor(params: any = {}) {
        super({
            ...params,
            status: params.status || HttpStatusCode.PAYMENT_REQUIRED,
        });
    }
}

class MethodNotAllowedError extends ErrorResponse {
    constructor(params: any = {}) {
        super({
            ...params,
            status: params.status || HttpStatusCode.METHOD_NOT_ALLOWED,
        });
    }
}
class NotAcceptableError extends ErrorResponse {
    constructor(params: any = {}) {
        super({
            ...params,
            status: params.status || HttpStatusCode.NOT_ACCEPTABLE,
        });
    }
}

class ProxyAuthenticationRequiredError extends ErrorResponse {
    constructor(params: any = {}) {
        super({
            ...params,
            status: params.status || HttpStatusCode.PROXY_AUTHENTICATION_REQUIRED,
        });
    }
}

class RequestTimeoutError extends ErrorResponse {
    constructor(params: any = {}) {
        super({
            ...params,
            status: params.status || HttpStatusCode.REQUEST_TIMEOUT,
        });
    }
}

class GoneError extends ErrorResponse {
    constructor(params: any = {}) {
        super({
            ...params,
            status: params.status || HttpStatusCode.GONE,
        });
    }
}

class LengthRequiredError extends ErrorResponse {
    constructor(params: any = {}) {
        super({
            ...params,
            status: params.status || HttpStatusCode.LENGTH_REQUIRED,
        });
    }
}

class PreconditionFailedError extends ErrorResponse {
    constructor(params: any = {}) {
        super({
            ...params,
            status: params.status || HttpStatusCode.PRECONDITION_FAILED,
        });
    }
}

class RequestTooLongError extends ErrorResponse {
    constructor(params: any = {}) {
        super({
            ...params,
            status: params.status || HttpStatusCode.REQUEST_TOO_LONG,
        });
    }
}

class RequestUriTooLongError extends ErrorResponse {
    constructor(params: any = {}) {
        super({
            ...params,
            status: params.status || HttpStatusCode.REQUEST_URI_TOO_LONG,
        });
    }
}

class UnsupportedMediaTypeError extends ErrorResponse {
    constructor(params: any = {}) {
        super({
            ...params,
            status: params.status || HttpStatusCode.UNSUPPORTED_MEDIA_TYPE,
        });
    }
}

class RequestedRangeNotSatisfiableError extends ErrorResponse {
    constructor(params: any = {}) {
        super({
            ...params,
            status: params.status || HttpStatusCode.REQUESTED_RANGE_NOT_SATISFIABLE,
        });
    }
}
class ExpectationFailedError extends ErrorResponse {
    constructor(params: any = {}) {
        super({
            ...params,
            status: params.status || HttpStatusCode.EXPECTATION_FAILED,
        });
    }
}

class ImATeapotError extends ErrorResponse {
    constructor(params: any = {}) {
        super({
            ...params,
            status: params.status || HttpStatusCode.IM_A_TEAPOT,
        });
    }
}

class InsufficientStorageError extends ErrorResponse {
    constructor(params: any = {}) {
        super({
            ...params,
            status: params.status || HttpStatusCode.INSUFFICIENT_STORAGE,
        });
    }
}

class MethodFailureError extends ErrorResponse {
    constructor(params: any = {}) {
        super({
            ...params,
            status: params.status || HttpStatusCode.METHOD_FAILURE,
        });
    }
}

class MisdirectedRequestError extends ErrorResponse {
    constructor(params: any = {}) {
        super({
            ...params,
            status: params.status || HttpStatusCode.MISDIRECTED_REQUEST,
        });
    }
}


class LockedError extends ErrorResponse {
    constructor(params: any = {}) {
        super({
            ...params,
            status: params.status || HttpStatusCode.LOCKED,
        });
    }
}

class FailedDependencyError extends ErrorResponse {
    constructor(params: any = {}) {
        super({
            ...params,
            status: params.status || HttpStatusCode.FAILED_DEPENDENCY,
        });
    }
}

class PreconditionRequiredError extends ErrorResponse {
    constructor(params: any = {}) {
        super({
            ...params,
            status: params.status || HttpStatusCode.PRECONDITION_REQUIRED,
        });
    }
}

class TooManyRequestsError extends ErrorResponse {
    constructor(params: any = {}) {
        super({
            ...params,
            status: params.status || HttpStatusCode.TOO_MANY_REQUESTS,
        });
    }
}

class RequestHeaderFieldsTooLargeError extends ErrorResponse {constructor(params: any = {}) {
	super({
		...params,
		status: params.status || HttpStatusCode.TOO_MANY_REQUESTS,
	});
}
}

class UnavailableForLegalReasonsError extends ErrorResponse {
    constructor(params: any = {}) {
        super({
            ...params,
            status: params.status || HttpStatusCode.UNAVAILABLE_FOR_LEGAL_REASONS,
        });
    }
}

const _ERROR = {
	ErrorResponse,
    BadRequestError, // 400
    ValidationError, // 409
	UnauthorizedError, // 401
	PaymentRequiredError, // 402
	ForbiddenError, // 403
	NotFoundError, // 404
	MethodNotAllowedError, // 405
	NotAcceptableError, // 406
	ProxyAuthenticationRequiredError, // 407
	RequestTimeoutError, // 408
	ConflictError, // 409
	GoneError, // 410
	LengthRequiredError, // 411
	PreconditionFailedError, // 412
	RequestTooLongError, // 413
	RequestUriTooLongError, // 414
	UnsupportedMediaTypeError, // 415
	RequestedRangeNotSatisfiableError, // 416
	ExpectationFailedError, // 417
	ImATeapotError, // 418
	InsufficientStorageError, // 419
	MethodFailureError, // 420
	MisdirectedRequestError, // 421
	UnprocessableEntityError, // 422
	LockedError, // 423
	FailedDependencyError, // 424
	PreconditionRequiredError, // 428
	TooManyRequestsError, // 429
	RequestHeaderFieldsTooLargeError, // 431
	UnavailableForLegalReasonsError, // 451
	InternalServerError, // 500
	NotImplementedError, // 501
	BadGatewayError, // 502
	ServiceUnavailableError, // 503
	GatewayTimeoutError, // 504
	HttpVersionNotSupportedError, // 505
	NetworkAuthenticationRequiredError // 511
};

export default _ERROR;


// // Authentication/Authorization
// 'permission-denied' -> ForbiddenError (403)
// 'unauthenticated' -> UnauthorizedError (401)

// // Resource Errors
// 'not-found' -> NotFoundError (404)
// 'already-exists' -> ConflictError (409)

// // Input Validation
// 'invalid-argument' -> BadRequestError (400)
// 'failed-precondition' -> PreconditionFailedError (412)

// // Rate Limiting
// 'resource-exhausted' -> TooManyRequestsError (429)

// // Server Issues
// 'unavailable' -> ServiceUnavailableError (503)
// 'internal' -> InternalServerError (500)
// 'deadline-exceeded' -> GatewayTimeoutError (504)

================================================
File: src/_core/helper/http-status/response-log.ts
================================================
import * as fs from 'fs';
import * as path from 'path';
import { config } from '../../config/dotenv.config';
import { getRequest } from '@/_core/middleware/displayRequest.middleware';
import { CustomRequest } from '../interfaces/CustomRequest.interface';
// const appDir = path.dirname(require.main?.filename || '');
const logDirRoot = config.logDir;


export function createLogger(logDir: string) {
    return {
        logError: (message: string) => {
            fs.appendFileSync(path.join(logDir, 'error-log.txt'), message + '\n', 'utf8');
        },
        logResponse: (message: string) => {
            fs.appendFileSync(path.join(logDir, 'response-log.txt'), message + '\n', 'utf8');
        }
    };
}

// Error logging format
export function createErrorLog<T>(req: CustomRequest<T>, error: any, startTime: number): string {
    const requestLog = getRequest(req);
    return `
_________________ REQUEST _________________
Request: ${req.method} ${req.originalUrl}
Duration: ${Date.now() - startTime}ms
${requestLog}
_________________ ERROR _________________
Error: ${error instanceof Error ? error.message : String(error)}
Stack: ${error instanceof Error ? error.stack : 'No stack trace available'}
__________________________________________
    `;
}

export function createLogDir(): string {
    const now = new Date();
    const date = now.toISOString().split('T')[0];
    const hour = now.getUTCHours().toString().padStart(2, '0');
    const logDir = path.join(logDirRoot, 'error', date, hour);
    fs.mkdirSync(logDir, { recursive: true });
    return logDir;
}

export function logResponse<T>(req: CustomRequest<T>, response: string) {
    const logDir = createLogDir();
    const logger = createLogger(logDir);
    console.log("response saved on:", logDir);
    logger.logError(createErrorLog(req, response, req.startTime || 0));
}

================================================
File: src/_core/helper/http-status/success/index.ts
================================================
import { NextFunction, Response } from 'express';
import { HttpStatusCode } from '../common/HttpStatusCode';
import { StatusCodes } from '../common/StatusCodes';
import { RestHandler } from '../common/RestHandler';
import { PaginationResult } from '../../interfaces/rest.interface';


class SuccessResponse {
    success: boolean;
    message: string;
    data: any;
    status: HttpStatusCode;
    metadata: any;
    options: any;
    pagination?: PaginationResult<any>;

    constructor({
        message,
        data = {},
        status = HttpStatusCode.OK,
        reasonPhrase = StatusCodes[status].phrase,
        pagination,
        options = {},
    }: {
        message?: string;
        data?: any;
        status?: HttpStatusCode;
        reasonPhrase?: string;
        metadata?: any;
        pagination?: PaginationResult<any>;
        options?: any;
    }) {
        this.success = true;
        this.message = message || reasonPhrase;
        this.data = data;
        this.status = status;
        this.metadata = this.formatMetadata(this.metadata);
        this.options = options;
        this.pagination = pagination;
    }

    /**
     * Format Metadata
     */
    private formatMetadata(metadata: any) {
        return {
            ...metadata,
        };
    }

    /**
     * Set Response Status Code
     */
    setStatus(status: number) {
        this.status = status;
        this.metadata.code = status;
        this.metadata.status = RestHandler.getStatusText(status);
        return this;
    }

    /**
     * Set Response Message
     */
    setMessage(message: string) {
        this.message = message;
        return this;
    }

    /**
     * Set Metadata
     */
    setMetadata(metadata: any) {
        this.metadata = { ...this.metadata, ...metadata };
        return this;
    }

    /**
     * Set Options
     */
    setOptions(options: any) {
        this.options = options;
        return this;
    }

    /**
     * Set Response Time
     */
    setResponseTime(startTime?: number) {
        const responseTime = startTime ? `${Date.now() - startTime}ms` : '0ms';
        this.metadata.responseTime = responseTime;
        return this;
    }

    /**
     * Set Custom Headers
     */
    setHeader(headers: Record<string, string>) {
        this.options.headers = { ...this.options.headers, ...headers };
        return this;
    }

    /**
     * Set Response Data
     */
    setData(data: any) {
        this.data = data;
        return this;
    }

    /**
     * Send Response
     */
    send(res: Response, next?: NextFunction) {
        try {
            this.preSendHooks();

            // Set Response Time if startTime exists on res.locals
            if (res.locals?.startTime) {
                this.setResponseTime(res.locals.startTime);
            }

            // Handle Headers
            // this.handleHeaders(res);

            // Send Response
            if (!res.headersSent) {
                const response = this.formatResponse();
                res.status(this.status).json(response);
            } else {
                console.warn('Attempted to send response after headers were already sent.');
            }

            this.postSendHooks();
        } catch (error) {
            console.error('Error sending response:', error);
            if (next) {
                next(error);
            } else {
                throw error;
            }
        }
    }

    /**
     * Pre-send Hooks
     */
    private preSendHooks() {
        this.metadata.timestamp = new Date().toISOString();
    }

    /**
     * Format Response
     */
    private formatResponse() {
        const response = {
            success: this.success,
            message: this.message,
            data: this.data,
            metadata: {
                ...this.metadata,
                code: this.status,
                status: RestHandler.getStatusText(this.status),
            },
        };

        if (Object.keys(this.options).length > 0) {
            Object.assign(response, { options: this.options });
        }

        return response;
    }

    /**
     * Handle Headers
    //  */
    // private handleHeaders(res: Response) {
    //     if (this.options?.headers) {
    //         Object.entries(this.options.headers).forEach(([key, value]) => {
    //             // Ensure value is converted to a valid header type
    //             const safeValue = Array.isArray(value)
    //                 ? value.map(v => String(v))
    //                 : String(value);
    //             res.setHeader(key, safeValue);
    //         });
    //     }
    
    //     res.setHeader('X-Response-Time', this.metadata.responseTime);
    // }
  

    /**
     * Post-send Hooks
     */
    private postSendHooks() {
        // Example: Logging or clean-up operations
        console.log(`Response sent with status: ${this.status}`);
    }
}

class OkSuccess extends SuccessResponse {
	constructor({
        message,
        status,
        metadata = {},
        options = {},
        data = {},
        pagination,
    }: {
        message?: string;
        status?: HttpStatusCode;
        metadata?: any;
        options?: any;
        data?: any;
        pagination?: PaginationResult<any>;
    }) {
        super({
            message,
            data,
            status : status || HttpStatusCode.OK,
            metadata,
            options,
            pagination,
        });
    }
}

class CreatedSuccess extends SuccessResponse {
	constructor({
        message,
        status,
        metadata = {},
        options = {},
        data = {},
    }: {
        message?: string;
        status?: HttpStatusCode;
        metadata?: any;
        options?: any;
        data?: any;
    }) {
        super({
            message,
            data,
            status : status || HttpStatusCode.CREATED,
            metadata,
            options,
        });
    }
}


class AcceptedSuccess extends SuccessResponse {
	constructor({
        message,
        status,
        metadata = {},
        options = {},
        data = {},
    }: {
        message?: string;
        status?: HttpStatusCode;
        metadata?: any;
        options?: any;
        data?: any;
    }) {
        super({
            message,
            data,
            status : status || HttpStatusCode.ACCEPTED,
            metadata,
            options,
        });
    }
}
class NoContentSuccess extends SuccessResponse {
	constructor({
        message,
        status,
        metadata = {},
        options = {},
        data = {},
    }: {
        message?: string;
        status?: HttpStatusCode;
        metadata?: any;
        options?: any;
        data?: any;
    }) {
        super({
            message,
            data,
            status : status || HttpStatusCode.NO_CONTENT,
            metadata,
            options,
        });
    }
}

class ResetContentSuccess extends SuccessResponse {
	constructor({
        message,
        status,
        metadata = {},
        options = {},
        data = {},
    }: {
        message?: string;
        status?: HttpStatusCode;
        metadata?: any;
        options?: any;
        data?: any;
    }) {
        super({
            message,
            data,
            status : status || HttpStatusCode.RESET_CONTENT,
            metadata,
            options,
        });
    }
}

class PartialContentSuccess extends SuccessResponse {
	constructor({
        message,
        status,
        metadata = {},
        options = {},
        data = {},
    }: {
        message?: string;
        status?: HttpStatusCode;
        metadata?: any;
        options?: any;
        data?: any;
    }) {
        super({
            message,
            data,
            status : status || HttpStatusCode.PARTIAL_CONTENT,
            metadata,
            options,
        });
    }
}

class NonAuthoritativeInformationSuccess extends SuccessResponse {
	constructor({
        message,
        status,
        metadata = {},
        options = {},
        data = {},
    }: {
        message?: string;
        status?: HttpStatusCode;
        metadata?: any;
        options?: any;
        data?: any;
    }) {
        super({
            message,
            data,
            status : status || HttpStatusCode.NON_AUTHORITATIVE_INFORMATION,
            metadata,
            options,
        });
    }
}
class MultiStatusSuccess extends SuccessResponse {
	constructor({
        message,
        status,
        metadata = {},
        options = {},
        data = {},
    }: {
        message?: string;
        status?: HttpStatusCode;
        metadata?: any;
        options?: any;
        data?: any;
    }) {
        super({
            message,
            data,
            status : status || HttpStatusCode.MULTI_STATUS,
            metadata,
            options,
        });
    }
}
class SeeOtherSuccess extends SuccessResponse {
	constructor({
        message,
        status,
        metadata = {},
        options = {},
        data = {},
    }: {
        message?: string;
        status?: HttpStatusCode;
        metadata?: any;
        options?: any;
        data?: any;
    }) {
        super({
            message,
            data,
            status : status || HttpStatusCode.SEE_OTHER,
            metadata,
            options,
        });
    }
}

class ProcessingSuccess extends SuccessResponse {
	constructor({
        message,
        status,
        metadata = {},
        options = {},
        data = {},
    }: {
        message?: string;
        status?: HttpStatusCode;
        metadata?: any;
        options?: any;
        data?: any;
    }) {
        super({
            message,
            data,
            status : status || HttpStatusCode.PROCESSING,
            metadata,
            options,
        });
    }
}

/**
 * Export Success Response
 */
const _SUCCESS = {
    SuccessResponse,
    OkSuccess, // 200
    CreatedSuccess, // 201
	AcceptedSuccess, // 202
	NoContentSuccess, // 204
	ResetContentSuccess, // 205
	PartialContentSuccess, // 206
	NonAuthoritativeInformationSuccess, // 203
	MultiStatusSuccess, // 207
	SeeOtherSuccess, // 303
	ProcessingSuccess // 102

};

export default _SUCCESS;


================================================
File: src/_core/helper/interfaces/CustomRequest.interface.ts
================================================
import { Request } from "express";
import { DecodedIdToken } from "firebase-admin/auth";

// Interface pour représenter les détails de l'utilisateur if not use firebase
// export interface UserContext {
//     contactDetails?: any; // Représente les détails du contact récupérés depuis Supabase
//     user?: any;
// }

// Étendre la requête Express pour inclure le contexte utilisateur
export interface ExtendedUserContextRequest extends Request {
    user?: DecodedIdToken;
}

// Étendre la requête pour inclure les paramètres supplémentaires
// Default case if no type is specified
type FallbackBody = { [key: string]: any };

// Generic CustomRequest Interface
export interface CustomRequest<T = FallbackBody> extends ExtendedUserContextRequest {
    startTime?: number;
    timestamp?: string;
    path: string;
    body: T;
}



================================================
File: src/_core/helper/interfaces/FetchPageResult.interface.ts
================================================
import { DocumentSnapshot } from "firebase-admin/firestore";
import { Timestamp } from "firebase/firestore";

export interface FetchPageResult<T> {
	/** The fetched data items */
	data: T[];

	/** Total number of items across all pages */
	totalItems: number;

	/** Number of items on the current page */
	count: number;

	/** Current page number (if paginated) */
	page: number;

	/** Total number of pages (if paginated) */
	totalPages: number;

	/** Items per page (if paginated) */
	limit: number;

	/** Indicates whether there is a next page */
	hasNext?: boolean;

	/** Indicates whether there is a previous page */
	hasPrev?: boolean;
}




export interface PaginationOptions {
	/** Current page number (logical pagination, not Firestore-native) */
	page?: number; // Default: 1

	/** Number of documents per page */
	limit?: number; // Default: 10

	/** Cursor-based pagination */
	lastVisible?: DocumentSnapshot; // Used for cursor-based pagination

	/** Sorting options */
	orderBy?: {
		field: string; // Firestore field to sort by
		direction?: 'asc' | 'desc'; // Sort direction
	};

	/** Filters (Firestore supports up to 30 composite filters) */
	filters?: {
		key: string; // Firestore document field
		value: string | number | boolean | Timestamp; // Supported Firestore types
		operator: FirebaseFirestore.WhereFilterOp; // Firestore comparison operator
	}[];

	/** Fetch all records (ignores pagination if true) */
	all?: boolean;

	/** Enable backend authentication checks */
	useBackendAuth?: boolean;
}


================================================
File: src/_core/helper/interfaces/rest.interface.ts
================================================
import { HATEOASLinks } from "express-route-tracker";
import { HttpStatusCode } from "../http-status/common/HttpStatusCode";
import { HttpMethod } from "../http-status/common/api-config";

export interface PaginationParams {
    page?: number;
    limit?: number;
    sort?: string;
    order?: 'asc' | 'desc';
}

export interface PaginationResult<T> {
    data: Partial<T>[]; // Ensure it's always an array
    page: number;
    limit: number;
    totalItems?: number;
    totalPages?: number;
    hasNext?: boolean;
    hasPrev?: boolean;
}


export interface MetaData {
    timestamp: string;
    statusCode?: string;
    path?: string;
    methode?: HttpMethod;
    request?: RequestMeta;
    responseTime?: string;
    links?: HATEOASLinks;
    description?: string;
    documentation?: string;
}

export interface RestResponse<T = any> {
    success?: boolean;
    code?: HttpStatusCode;
    message?: string;
    data?: Partial<T> | Partial<T>[];
    pagination?: PaginationResult<T>;
    metadata: MetaData;
    errors?: ValidationError[];
}

export interface ValidationError {
    field: string;
    message: string;
    code?: string;
}

export interface RequestMeta {
    id?: string;
    timestamp?: string;
    method?: string;
    url?: string;
}


================================================
File: src/_core/helper/validateZodSchema/__tests__/validateSchema.spec.ts
================================================
import { z, ZodError } from 'zod';
import { ErrorResponse } from '../../http-status/error';
import { HttpStatusCode } from '../../http-status/common/HttpStatusCode';
import { validateSchema } from '..';

describe('validateSchema', () => {
  const testSchema = z.object({
    name: z.string().min(2, 'Name must be at least 2 characters'),
    email: z.string().email('Invalid email format'),
    age: z.number().min(18, 'Age must be at least 18'),
  });

  let mockRequest: any;

  beforeEach(() => {
    mockRequest = {
      body: {
        name: 'John Doe',
        email: 'john@example.com',
        age: 25,
      },
    };
  });

  // ✅ Test Case 1: Valid Data
  it('should pass validation with valid data', () => {
    expect(() => validateSchema(testSchema)(mockRequest)).not.toThrow();
  });

  // ✅ Test Case 2: Invalid Email
  it('should throw ErrorResponse with invalid email', () => {
    mockRequest.body.email = 'invalid-email';

    try {
      validateSchema(testSchema)(mockRequest);
      fail('Should have thrown an ErrorResponse');
    } catch (error) {
      expect(error).toBeInstanceOf(ErrorResponse);
      expect((error as ErrorResponse).status).toBe(HttpStatusCode.BAD_REQUEST);
      expect((error as ErrorResponse).message).toBe('Validation Error');
      expect((error as ErrorResponse).errors).toEqual([
        expect.objectContaining({
          field: 'email',
          message: 'Invalid email format',
        }),
      ]);
    }
  });

  // ✅ Test Case 3: Multiple Validation Errors
  it('should handle multiple validation errors', () => {
    mockRequest.body = {
      name: 'J',
      email: 'invalid',
      age: 15,
    };

    try {
      validateSchema(testSchema)(mockRequest);
      fail('Should have thrown an ErrorResponse');
    } catch (error) {
      expect(error).toBeInstanceOf(ErrorResponse);
      expect((error as ErrorResponse).status).toBe(HttpStatusCode.BAD_REQUEST);
      expect((error as ErrorResponse).errors).toHaveLength(3);
      expect((error as ErrorResponse).errors).toEqual(
        expect.arrayContaining([
          expect.objectContaining({ field: 'name', message: 'Name must be at least 2 characters' }),
          expect.objectContaining({ field: 'email', message: 'Invalid email format' }),
          expect.objectContaining({ field: 'age', message: 'Age must be at least 18' }),
        ])
      );
    }
  });

  // ✅ Test Case 4: Non-Zod Errors
  it('should handle non-Zod errors', () => {
    const error = new Error('Test error');
    jest.spyOn(testSchema, 'parse').mockImplementation(() => {
      throw error;
    });

    expect(() => validateSchema(testSchema)(mockRequest)).toThrow(error);
  });

  // ✅ Test Case 5: Nested Field Validation Errors
  it('should handle nested field validation errors', () => {
    const nestedSchema = z.object({
      user: z.object({
        profile: z.object({
          name: z.string().min(2, 'Name must be at least 2 characters'),
        }),
      }),
    });

    mockRequest.body = {
      user: {
        profile: {
          name: 'A',
        },
      },
    };

    try {
      validateSchema(nestedSchema)(mockRequest);
      fail('Should have thrown an ErrorResponse');
    } catch (error) {
      // Ensure the error is an instance of ErrorResponse
      expect(error).toBeInstanceOf(ErrorResponse);
      
      const errorResponse = error as ErrorResponse;
    
      // Ensure the status code is correct
      expect(errorResponse.status).toBe(HttpStatusCode.BAD_REQUEST);
    
      // Check if errors exist and have valid entries
      expect(errorResponse.errors).toBeDefined();
      expect(Array.isArray(errorResponse.errors)).toBe(true);
      expect(errorResponse.errors?.length).toBeGreaterThan(0);
    
      // Safely access the first error using optional chaining
      const firstError = errorResponse.errors?.[0];
    
      expect(firstError).toBeDefined(); // Ensure there's at least one error
      expect(firstError?.field).toBe('user.profile.name');
      expect(firstError?.message).toBe('Name must be at least 2 characters');
    }
  });

  // ✅ Test Case 6: Missing Required Field
  it('should handle missing required fields', () => {
    mockRequest.body = {
      email: 'valid@example.com',
      age: 25,
    };

    try {
      validateSchema(testSchema)(mockRequest);
      fail('Should have thrown an ErrorResponse');
    } catch (error) {
      expect(error).toBeInstanceOf(ErrorResponse);
    
      const errorResponse = error as ErrorResponse;
    
      // Ensure errors exist and are not empty
      expect(errorResponse.errors).toBeDefined();
      expect(Array.isArray(errorResponse.errors)).toBe(true);
      expect(errorResponse.errors!.length).toBeGreaterThan(0);
    
      // Access the first error safely
      const firstError = errorResponse.errors?.[0];
      expect(firstError).toBeDefined();
      expect(firstError?.field).toBe('user.profile.name');
      expect(firstError?.message).toBe('Name must be at least 2 characters');
    }
  });
});


================================================
File: src/_core/helper/validateZodSchema/index.ts
================================================
import { ZodSchema, ZodError } from 'zod';
import { Request, Response, NextFunction } from 'express';
import { HttpStatusCode } from '@/_core/helper/http-status/common/HttpStatusCode';
import { ErrorResponse } from '@/_core/helper/http-status/error';

/**
 * Middleware for validating request data with Zod schema
 * @param schema ZodSchema for validation
 * @param type 'body' | 'params' | 'query'
 */
export function validateDTO(schema: ZodSchema, type: 'body' | 'params' | 'query' = 'body') {
    return (req: Request, res: Response, next: NextFunction) => {
        try {
            const dataToValidate = {
                body: req.body,
                params: req.params,
                query: req.query,
            }[type]; // Dynamically pick the validation target

            schema.parse(dataToValidate); // Validate the selected data

            next(); // Proceed to the next middleware/controller if valid
        } catch (err) {
            if (err instanceof ZodError) {
                return res.status(HttpStatusCode.BAD_REQUEST).json(
                    new ErrorResponse({
                        status: HttpStatusCode.BAD_REQUEST,
                        message: 'Validation Error',
                        errors: err.issues.map((issue) => ({
                            field: issue.path.join('.'),
                            message: issue.message,
                        })),
                    })
                );
            }
            next(err); // Pass unexpected errors to the error handler
        }
    };
}


================================================
File: src/_core/logger/__tests__/simple-logger.spec.ts
================================================
jest.mock('path', () => {
  const originalPath = jest.requireActual('path');
  return {
    ...originalPath,
    join: jest.fn((...args: string[]) => originalPath.join('D:\\DaiHung\\__labo\\AIanalist', ...args.slice(1))),
  };
});
import fs from 'fs';
import path from 'path';
import { SimpleLogger } from '../simple-logger';

jest.mock('fs');
jest.spyOn(console, 'log').mockImplementation(); // Suppress console output in tests

describe('SimpleLogger', () => {
  let logger: SimpleLogger;
  let logDir: string;
  let logFile: string;

  beforeEach(() => {
    jest.clearAllMocks();

    logDir = path.resolve(__dirname, '../../../logs');
    logFile = path.join(logDir, `app-${new Date().toISOString().split('T')[0]}.log`);

    (fs.existsSync as jest.Mock).mockReturnValue(false);
    (fs.mkdirSync as jest.Mock).mockImplementation();
    (fs.appendFileSync as jest.Mock).mockImplementation();

    logger = new SimpleLogger();
  });

  // ✅ Test: Log Directory Creation
//   it('should create the log directory if it does not exist', () => {
//     expect(fs.existsSync).toHaveBeenCalledWith(logDir);
//     expect(fs.mkdirSync).toHaveBeenCalledWith(logDir, { recursive: true });
//   });

  // ✅ Test: Log File Path
  it('should set the correct log file path', () => {
    expect(logger).toHaveProperty('logFile', logFile);
  });

  // ✅ Test: Info Log
  it('should write an info log message to the file and console', () => {
    logger.info('Test info message', { key: 'value' });

    expect(console.log).toHaveBeenCalledWith(
      expect.stringContaining('[INFO] Test info message')
    );
    expect(fs.appendFileSync).toHaveBeenCalledWith(
      expect.stringMatching(/app-\d{4}-\d{2}-\d{2}\.log$/),
      expect.stringContaining('[INFO] Test info message')
    );
  });

  // ✅ Test: Error Log
  it('should write an error log message to the file and console', () => {
    const error = new Error('Test error');
    logger.error('Test error message', error);

    expect(console.log).toHaveBeenCalledWith(
      expect.stringContaining('[ERROR] Test error message')
    );
    expect(fs.appendFileSync).toHaveBeenCalledWith(
      expect.stringMatching(/app-\d{4}-\d{2}-\d{2}\.log$/),
      expect.stringContaining('Test error')
    );
  });

  // ✅ Test: Warn Log
  it('should write a warn log message to the file and console', () => {
    logger.warn('Test warn message', { key: 'warnValue' });

    expect(console.log).toHaveBeenCalledWith(
      expect.stringContaining('[WARN] Test warn message')
    );
    expect(fs.appendFileSync).toHaveBeenCalledWith(
      expect.stringMatching(/app-\d{4}-\d{2}-\d{2}\.log$/),
      expect.stringContaining('[WARN] Test warn message')
    );
  });

  // ✅ Test: Debug Log
  it('should write a debug log message to the file and console', () => {
    logger.debug('Test debug message', { debugKey: 'debugValue' });

    expect(console.log).toHaveBeenCalledWith(
      expect.stringContaining('[DEBUG] Test debug message')
    );
    expect(fs.appendFileSync).toHaveBeenCalledWith(
      expect.stringMatching(/app-\d{4}-\d{2}-\d{2}\.log$/),
      expect.stringContaining('[DEBUG] Test debug message')
    );
  });

  // ✅ Test: Metadata Logging
  it('should include metadata in the log', () => {
    logger.info('Test metadata', { metaKey: 'metaValue' });

    expect(fs.appendFileSync).toHaveBeenCalledWith(
      expect.stringMatching(/app-\d{4}-\d{2}-\d{2}\.log$/),
      expect.stringContaining('{"metaKey":"metaValue"}')
    );
  });

  // ✅ Test: Log without Metadata
  it('should handle logs without metadata gracefully', () => {
    logger.info('Test without metadata');

    expect(fs.appendFileSync).toHaveBeenCalledWith(
      expect.stringMatching(/app-\d{4}-\d{2}-\d{2}\.log$/),
      expect.stringContaining('[INFO] Test without metadata')
    );
  });
});


================================================
File: src/_core/logger/simple-logger.ts
================================================
import path = require("path");
import fs = require("fs");

export class SimpleLogger {
    private logFile: string;

    constructor() {
        const logDir = path.join(__dirname, '../../../logs');
		// console.log('logDir: ' + logDir);
        if (!fs.existsSync(logDir)) {
            fs.mkdirSync(logDir, { recursive: true });
        }
        this.logFile = path.join(logDir, `app-${new Date().toISOString().split('T')[0]}.log`);
    }

    private log(level: string, message: string, meta?: any): void {
        const timestamp = new Date().toISOString();
        const logMessage = `${timestamp} [${level}] ${message} ${meta ? JSON.stringify(meta) : ''}
`;
        console.log(logMessage.trim());
        fs.appendFileSync(this.logFile, logMessage);
    }

    info(message: string, meta?: any): void {
        this.log('INFO', message, meta);
    }

    error(message: string, error: Error): void {
        this.log('ERROR', message, { error: error.stack });
    }

    warn(message: string, meta?: any): void {
        this.log('WARN', message, meta);
    }

    debug(message: string, meta?: any): void {
        this.log('DEBUG', message, meta);
    }
}


================================================
File: src/_core/middleware/__tests__/displayRequest.spec.ts
================================================
import { Request, Response, NextFunction } from 'express';
import { displayRequest, getRequest } from '../displayRequest.middleware';
import { blueBright, blue, yellow, greenBright } from 'colorette';

jest.mock('colorette', () => ({
  bgWhite: jest.fn((text) => text),
  bgMagenta: jest.fn((text) => text),
  blueBright: jest.fn((text) => text),
  blue: jest.fn((text) => text),
  yellow: jest.fn((text) => text),
  greenBright: jest.fn((text) => text),
}));

describe('displayRequest Middleware', () => {
  let req: Partial<Request>;
  let res: Partial<Response>;
  let next: NextFunction;

  beforeEach(() => {
    jest.clearAllMocks();
    req = {
      originalUrl: '/test-route',
      method: 'GET',
      body: { key: 'value' },
      params: { id: '123' },
      query: { search: 'query' },
      headers: { host: 'localhost:3000' },
    };
    res = {};
    next = jest.fn();
    console.log = jest.fn();
  });

  it('should log request details correctly', () => {
    displayRequest(req as Request, res as Response, next);

    expect(console.log).toHaveBeenCalledWith(expect.stringContaining('showRequest'));
    expect(console.log).toHaveBeenCalledWith(
      'Request URL:',
      expect.stringContaining(`${blueBright('localhost:3000')}${blue('/test-route')}`)
    );
    expect(console.log).toHaveBeenCalledWith('Method:', yellow('GET'));
    expect(console.log).toHaveBeenCalledWith('Body:', greenBright(JSON.stringify({ key: 'value' }, null, 2)));
    expect(console.log).toHaveBeenCalledWith('Params:', JSON.stringify({ id: '123' }, null, 2));
    expect(console.log).toHaveBeenCalledWith('Query:', JSON.stringify({ search: 'query' }, null, 2));
    expect(next).toHaveBeenCalled();
  });
});

describe('getRequest Utility', () => {
  let req: Partial<Request>;

  beforeEach(() => {
    req = {
      originalUrl: '/test-route',
      method: 'POST',
      body: { data: 'test' },
      params: { id: '456' },
      query: { filter: 'active' },
      headers: { host: 'example.com' },
    };
  });

  it('should return request details as a formatted string', () => {
    const result = getRequest(req as Request);
    const parsedResult = JSON.parse(result);

    expect(parsedResult).toEqual(
      expect.objectContaining({
        url: 'example.com/test-route',
        method: 'POST',
        body: { data: 'test' },
        params: { id: '456' },
        query: { filter: 'active' },
      })
    );
    expect(parsedResult.timestamp).toEqual(expect.any(String));
  });

    it('should handle missing properties gracefully', () => {
        req = {};
        const result = getRequest(req as Request);
        const parsedResult = JSON.parse(result);

        expect(parsedResult).toEqual({
            timestamp: expect.any(String),
            url: undefined,
            method: undefined,
            body: undefined,
            params: undefined,
            query: undefined,
        });
    });
});


================================================
File: src/_core/middleware/__tests__/responseLogger.spec.ts
================================================
import { Request, Response, NextFunction } from 'express';
import { responseLogger } from '../responseLogger.middleware';

describe('responseLogger Middleware', () => {
    let req: Partial<Request>;
    let res: Partial<Response>;
    let next: NextFunction;
    let consoleLogSpy: jest.SpyInstance;
    let originalSend: any;

    beforeEach(() => {
        jest.clearAllMocks();

        req = {
            originalUrl: '/test-url',
            method: 'GET',
        };

        res = {
            statusCode: 200,
            send: jest.fn(),
        };

        next = jest.fn();
        consoleLogSpy = jest.spyOn(console, 'log').mockImplementation();

        // Store a reference to the original `res.send`
        originalSend = res.send;
    });

    it('should log the request and response details', () => {
        const mockBody = JSON.stringify({ message: 'Success' });

        // Apply middleware
        responseLogger(req as Request, res as Response, next);

        // Simulate res.send
        (res.send as any)(mockBody);

        expect(consoleLogSpy).toHaveBeenCalledWith('[Response Logger]');
        expect(consoleLogSpy).toHaveBeenCalledWith('➡️ URL:', '/test-url');
        expect(consoleLogSpy).toHaveBeenCalledWith('➡️ Method:', 'GET');
        expect(consoleLogSpy).toHaveBeenCalledWith('➡️ Status Code:', 200);
        expect(consoleLogSpy).toHaveBeenCalledWith('➡️ Response Body:', { message: 'Success' });

        expect(originalSend).toHaveBeenCalledWith(mockBody);
        expect(next).toHaveBeenCalled();
    });

    it('should pass control to the next middleware', () => {
        responseLogger(req as Request, res as Response, next);
        expect(next).toHaveBeenCalled();
    });
});


================================================
File: src/_core/middleware/auth.middleware.ts
================================================
import { Request, Response, NextFunction } from 'express';
import * as admin from 'firebase-admin';
import { RestHandler } from '../helper/http-status/common/RestHandler';
import { HttpStatusCode } from '../helper/http-status/common/HttpStatusCode';

// Ensure Firebase is initialized
if (!admin.apps.length) {
    admin.initializeApp({
        credential: admin.credential.applicationDefault(),
    });
}

/**
 * Middleware to authenticate Firebase token
 */
export async function firebaseAuthMiddleware(req: Request, res: Response, next: NextFunction) {
    const token = req.headers.authorization?.split(' ')[1];

    if (!token) {

        return RestHandler.error(req, res, {
            code: HttpStatusCode.UNAUTHORIZED,
            message: 'Unauthorized: No token provided',
        });        
    }

    try {
        const decodedToken: admin.auth.DecodedIdToken = await admin.auth().verifyIdToken(token);
        (req as any).user = decodedToken; // Attach user info to request
        next(); // Proceed to the next middleware or route handler
    } catch (error) {
        console.error('Firebase Auth Error:', error);
        return RestHandler.error(req, res, {
            code: HttpStatusCode.UNAUTHORIZED,
            message: 'Unauthorized: Invalid or expired token',
        });       
    }
}


================================================
File: src/_core/middleware/creates-HATEOAS.middleware.txt
================================================
import { HATEOASLinks, HATEOASOptions } from "../helper/interfaces/rest.interface";
import { Request, Response, NextFunction, Router } from 'express';


export function createHATEOASMiddleware(router: Router, options: HATEOASOptions = { autoIncludeSameRoute: false }) {
    return function hateoasMiddleware(req: Request, res: Response, next: NextFunction) {
        const originalJson = res.json;
        const baseUrl = options.baseUrl || '';
        
        // Get the source file from the router
        const sourceFile = (router as any).__source;
        console.log('Router source:', sourceFile);
        
        if (!sourceFile) {
            console.warn('No source file found on router');
            next();
            return;
        }
        
        // Log the router structure for debugging
        console.log('Router stack size:', (router as any).stack.length);
        console.log('Router prototype chain:', Object.getPrototypeOf(router));

        // Collect all routes from the same source file
        const routes = collectRoutesFromSameSource(router, sourceFile);

        res.json = function(body: any) {
            if (body && typeof body === 'object') {
                const links: HATEOASLinks = {
                    self: {
                        rel: 'self',
                        href: `${baseUrl}${req.originalUrl}`,
                        method: req.method as any
                    }
                };

                // Add pagination links if enabled and pagination data exists
                if (options.includePagination && body.pagination) {
                    const { currentPage, totalPages } = body.pagination;
                    const baseLink = `${baseUrl}${req.path}`;

                    if (totalPages > 1) {
                        links.first = {
                            rel: 'first',
                            href: `${baseLink}?page=1`,
                            method: 'GET'
                        };

                        if (currentPage > 1) {
                            links.prev = {
                                rel: 'prev',
                                href: `${baseLink}?page=${currentPage - 1}`,
                                method: 'GET'
                            };
                        }

                        if (currentPage < totalPages) {
                            links.next = {
                                rel: 'next',
                                href: `${baseLink}?page=${currentPage + 1}`,
                                method: 'GET'
                            };
                        }

                        links.last = {
                            rel: 'last',
                            href: `${baseLink}?page=${totalPages}`,
                            method: 'GET'
                        };
                    }
                }

                // Add related route links from the same file
                if (options.autoIncludeSameRoute !== false) {
                    // Extract base path from the current request
                    const basePath = req.baseUrl || '';
                    console.log('Base path:', basePath);
                    
                    routes.forEach(route => {
                        // Generate the actual route path with parameters
                        const routePath = route.path.replace(/:[^/]+/g, (match) => {
                            const param = match.substring(1);
                            return req.params[param] || body[param] || match;
                        });

                        // Normalize paths for comparison
                        const normalizedCurrentPath = req.route ? normalizeRoutePath(req.route.path) : '';
                        const normalizedRoutePath = normalizeRoutePath(route.path);
                        
                        // Determine if this is the current route
                        const isCurrentRoute = (
                            route.method.toUpperCase() === req.method &&
                            normalizedCurrentPath === normalizedRoutePath
                        );

                        // Include the route if autoIncludeSameRoute is true or it's not the current route
                        if (options.autoIncludeSameRoute === true || !isCurrentRoute) {
                            const linkName = generateRelationship(route.method, route.path);
                            links[linkName] = {
                                title: `${route.method.toUpperCase()} ${route.path}`,
                                rel: linkName,
                                href: `${baseUrl}${basePath}${routePath}`,
                                method: route.method.toUpperCase() as any,
                            };
                        }
                    });
                }

                // Add custom links if defined
                if (options.customLinks) {
                    Object.entries(options.customLinks).forEach(([key, generator]) => {
                        const customLink = generator(req as any);
                        if (customLink) {
                            links[key] = customLink;
                        }
                    });
                }

                // Add links to the response
                body.links = links;
            }

            return originalJson.call(this, body);
        };

        next();
    };
}

/**
 * Collects all routes from the same source file
 */
function collectRoutesFromSameSource(router: Router, sourceFile: string) {
    const routes: Array<{ method: string; path: string }> = [];
    const stack = (router as any).stack;

    console.log('Source file:', sourceFile);
    console.log('Stack length:', stack.length);

    stack.forEach((layer: any) => {
        // If this layer has a route, include it (since we're already working with the correct router)
        if (layer.route) {
            const routePath = layer.route.path;
            const routeMethods = layer.route.methods;

            console.log('Found route:', {
                path: routePath,
                methods: routeMethods
            });

            Object.keys(routeMethods).forEach(method => {
                routes.push({
                    method: method,
                    path: routePath
                });
            });
        }
    });

    console.log('Collected routes:', routes);
    return routes;
}

/**
 * Normalizes a route path for comparison by:
 * 1. Removing trailing slashes
 * 2. Replacing parameter names with placeholder
 * @param path The route path to normalize
 */
function normalizeRoutePath(path: string): string {
    return path
        .replace(/\/$/, '') // Remove trailing slash
        .replace(/:[^/]+/g, ':param') // Replace all parameters with a standard placeholder
        .replace(/^\//, ''); // Remove leading slash
}

/**
 * Generates a meaningful relationship name for a link based on the HTTP method and path
 */
function generateRelationship(method: string, path: string): string {
    // Common RESTful relationships
    if (path === '/' || path === '') {
        switch (method.toLowerCase()) {
            case 'get': return 'collection';
            case 'post': return 'create';
            default: return method.toLowerCase();
        }
    }

    if (path.includes(':id')) {
        switch (method.toLowerCase()) {
            case 'get': return 'item';
            case 'put': return 'update';
            case 'delete': return 'delete';
            case 'patch': return 'partial-update';
            default: return method.toLowerCase();
        }
    }

    // For any other paths, create a semantic relationship
    const cleanPath = path.replace(/^\/|\/$/g, '')  // Remove leading/trailing slashes
                         .replace(/:/g, '')          // Remove colon from parameters
                         .replace(/\//g, '-');       // Replace slashes with dashes
    
    return `${method.toLowerCase()}-${cleanPath}`;
}

================================================
File: src/_core/middleware/displayRequest.middleware.ts
================================================
import { Request, Response, NextFunction } from 'express';
import { isEmpty } from 'lodash';
import { bgMagenta, bgWhite, blue, blueBright, greenBright, yellow } from 'colorette';

export function displayRequest(req: Request, _: Response, next: NextFunction): void {
    const timestamp = new Date().toLocaleString();
    console.log(bgWhite("\n" + "showRequest: " + timestamp));
    if (!isEmpty(req.originalUrl)) console.log('Request URL:', `${blueBright(req.headers.host ?? 'host_not_found')}${blue(req.originalUrl)}`);
    if (!isEmpty(req.method)) console.log('Method:', yellow(req.method));
    if (!isEmpty(req.body)) console.log('Body:', greenBright(JSON.stringify(req.body, null, 2)));
    if (!isEmpty(req.params)) console.log('Params:', JSON.stringify(req.params, null, 2));
    if (!isEmpty(req.query)) console.log('Query:', JSON.stringify(req.query, null, 2));
    console.log(bgMagenta("\n"));
    next();
}

export function getRequest(req: Request): string {
    const requestData = {
        timestamp: new Date().toLocaleString(),
        url: req.headers?.host && req.originalUrl ? `${req.headers.host}${req.originalUrl}` : undefined,
        method: !isEmpty(req.method) ? req.method : undefined,
        body: !isEmpty(req.body) ? req.body : undefined,
        params: !isEmpty(req.params) ? req.params : undefined,
        query: !isEmpty(req.query) ? req.query : undefined
    };

    // Ensure all properties are explicitly included
    return JSON.stringify({
        timestamp: requestData.timestamp,
        url: requestData.url || undefined,
        method: requestData.method || undefined,
        body: requestData.body || undefined,
        params: requestData.params || undefined,
        query: requestData.query || undefined,
    }, null, 2);
}


================================================
File: src/_core/middleware/responseLogger.middleware.ts
================================================

import { Request, Response, NextFunction } from 'express';

export const responseLogger = (req: Request, res: Response, next: NextFunction) => {
    const originalSend = res.send;

    (res.send as any) = (body: any) => {
        console.log('[Response Logger]');
        console.log('➡️ URL:', req.originalUrl);
        console.log('➡️ Method:', req.method);
        console.log('➡️ Status Code:', res.statusCode);
        console.log('➡️ Response Body:', JSON.parse(body));

        return originalSend.call(res, body); // Explicitly call with 'res'
    };

    next();
};


================================================
File: src/_core/middleware/start-time.middleware.ts
================================================
import { NextFunction, Response } from "express";
import { CustomRequest } from "../helper/interfaces/CustomRequest.interface";


export const startTimeAddOnRequest = (req: CustomRequest, _res: Response, next: NextFunction) => {
	req.startTime = Date.now();
	next();
}

================================================
File: src/_core/server/app/__tests__/app.spec.ts
================================================
// src/_core/server/app/__tests__/app.spec.ts
import { app } from '../app.service';
import http from 'http';

jest.mock('express-rate-limit');
jest.mock('helmet');
jest.mock('@/_core/database/firebase');
jest.mock('express-route-tracker/dist', () => ({
 RouteDisplay: jest.fn().mockImplementation(() => ({
   displayRoutes: jest.fn()
 }))
}));
jest.mock('@modules/index', () => {
 const express = require('express');
 const router = express.Router();

 return router;
});

describe('AppService', () => {
 let server: http.Server;

 beforeAll((done) => {
   server = app.listen(4000, done);
 });

 afterAll((done) => {
   server.close(done);
 });


 describe('Server Creation', () => {
   it('should create HTTP server in development', () => {
     expect(server).toBeInstanceOf(http.Server);
   });
 });
});

================================================
File: src/_core/server/app/app.service.ts
================================================
import cors from 'cors'; // Correct way to import
import express from 'express';
import * as fs from "fs";
import * as http from "http";
import * as https from "https";
import * as path from "path";
import { checkSystemOverload } from '../../helper/check-system-overload/check-system-overload';
import { SimpleLogger } from '../../logger/simple-logger'; // Assuming SimpleLogger is used for logging
// Determine the environment and load the corresponding .env file
import { config, showConfig } from '@/_core/config/dotenv.config';
import { testFirestoreAccess } from '@/_core/database/firebase-admin-sdk';
import { API_CONFIG } from '@/_core/helper/http-status/common/api-config';
import { HttpStatusCode } from '@/_core/helper/http-status/common/HttpStatusCode';
import { RestHandler } from '@/_core/helper/http-status/common/RestHandler';
import { StatusCodes } from '@/_core/helper/http-status/common/StatusCodes';
import _ERROR from '@/_core/helper/http-status/error';
import { displayRequest } from '@/_core/middleware/displayRequest.middleware';
import { responseLogger } from '@/_core/middleware/responseLogger.middleware';
import router from "@modules/index";
import rateLimit from '@node_modules/express-rate-limit';
import { RouteDisplay } from '@node_modules/express-route-tracker/dist';
import helmet from '@node_modules/helmet/index.cjs';
import { isRunningWithNodemon } from '@src/_core/helper/check-nodemon';
import { blue, green, yellow } from 'colorette';
import { NextFunction, Request, Response } from 'express';
import { startTimeAddOnRequest } from '@/_core/middleware/start-time.middleware';

const env = config.env;
const pathToEnvFile = path.resolve(__dirname, `../../../../environment/.env.${env}`);
const envFile = path.resolve(pathToEnvFile);

isRunningWithNodemon()

// Load environment variables from the .env file
console.log(green(`Loading environment from  ${blue(envFile)}`));
console.log(
	green(`All environment variables are ${yellow(process.env.TEST_VAR || 'N/A')} on mode ${yellow(process.env.NODE_ENV || 'N/A')}`)
);

console.log(showConfig());

/**
 * Service class for managing the server application
 */
export class AppService {
	private static instance: AppService;
	readonly app = express();
	private logger: SimpleLogger = new SimpleLogger();
	private port: number | string = process.env.PORT || 3000;

	constructor() {
		if (AppService.instance) {
			return AppService.instance;
		}
		this.logger = new SimpleLogger();
		AppService.instance = this;
	}

	public static getInstance(): AppService {
		if (!AppService.instance) {
			new AppService();
		}
		return AppService.instance;
	}

	/**
	 * Initialize middleware and settings
	 */
	private async init(): Promise<void> {
		app.use(startTimeAddOnRequest);
		this.setupCors();
		app.use(helmet());
		app.use(rateLimit({
			windowMs: 15 * 60 * 1000, // 15 minutes
			max: 100 // limit each IP to 100 requests per windowMs
		}));
		this.setupRateLimit();
		this.setupJsonParser();
		app.use(displayRequest);
		app.use(responseLogger);
		// Initialize and display routes after loading all modules
		app.use("/", router);
		const routeDisplay = new RouteDisplay(app);
		routeDisplay.displayRoutes();

		/**
		 * 🟡 1️⃣ Catch 404 - Not Found Middleware (3 arguments)
		 * Handles requests to undefined routes.
		 */
		app.use((_req: Request, _res: Response, _next: NextFunction) => {
			throw new _ERROR.NotFoundError({
				message: 'The requested resource was not found.',
			});
		});

		/**
		 * 🟠 2️⃣ Specific Error Handling Middleware (4 arguments)
		 * Handles specific known error types.
		 */
		app.use((err: any, _req: Request, res: Response, next: NextFunction) => {
			// 🔹 Malformed JSON in the request body
			if (err instanceof SyntaxError && err.message.includes('Unexpected')) {
				return res.status(HttpStatusCode.BAD_REQUEST).json({
					code: HttpStatusCode.BAD_REQUEST,
					message: 'Malformed JSON in request body. Please verify your payload.',
				});
			}

			// 🔹 Payload Too Large
			if (err.type === 'entity.too.large') {
				return res.status(HttpStatusCode.REQUEST_TOO_LONG).json({
					code: HttpStatusCode.REQUEST_TOO_LONG,
					message: 'Payload too large. Please reduce the request body size.',
				});
			}

			// 🔹 Unauthorized Access
			if (err.code === 'UNAUTHORIZED') {
				return res.status(HttpStatusCode.UNAUTHORIZED).json({
					code: HttpStatusCode.UNAUTHORIZED,
					message: 'Unauthorized access. Please provide valid credentials.',
				});
			}

			// 🔹 Forbidden Access
			if (err.code === 'FORBIDDEN') {
				return res.status(HttpStatusCode.FORBIDDEN).json({
					code: HttpStatusCode.FORBIDDEN,
					message: 'You do not have permission to access this resource.',
				});
			}

			// 🔹 Validation Errors
			if (err.name === 'ValidationError') {
				return res.status(HttpStatusCode.BAD_REQUEST).json({
					code: HttpStatusCode.BAD_REQUEST,
					message: 'Validation Error. Please check your input fields.',
					errors: err.errors || [],
				});
			}

			// 🔹 Timeout Errors
			if (err.code === 'ETIMEDOUT') {
				return res.status(HttpStatusCode.REQUEST_TIMEOUT).json({
					code: HttpStatusCode.REQUEST_TIMEOUT,
					message: 'The request timed out. Please try again later.',
				});
			}

			// Pass other errors to the global handler
			next(err);
		});

		/**
		 * 🔴 3️⃣ General Error Handling Middleware (4 arguments)
		 * Handles all uncaught errors and returns a consistent response format.
		 */
		app.use((error: any, req: Request, res: Response, _next: NextFunction) => {
			const statusCode = error.status || HttpStatusCode.INTERNAL_SERVER_ERROR;
			const message = error.message 
							|| StatusCodes[error.status as unknown as HttpStatusCode].phrase 
							|| StatusCodes[HttpStatusCode.INTERNAL_SERVER_ERROR].phrase;

			RestHandler.error(req, res, {
				code: statusCode,
				message,
				errors: error.errors || [],
			});
		});
	}

	/**
	 * Setup Rate Limiting Middleware
	 */
	setupRateLimit(): void {
		app.use(rateLimit({
			windowMs: API_CONFIG.RATE_LIMIT.WINDOW_MS,
			max: API_CONFIG.RATE_LIMIT.MAX_REQUESTS,
			message: 'Too many requests from this IP, please try again later.',
			standardHeaders: true, // Return rate limit info in the `RateLimit-*` headers
			legacyHeaders: false, // Disable `X-RateLimit-*` headers
		}));
		console.log('✅ Rate limiting configured successfully.');
	}

	/**
	 * Setup JSON Parsing Middleware
	 */
	setupJsonParser(): void {
		app.use(express.json({
			limit: API_CONFIG.JSON.LIMIT,
		}));
		console.log(`✅ JSON body limit set to ${API_CONFIG.JSON.LIMIT}.`);
	}

	/**
	 * Setup CORS based on environment
	 */
	setupCors(): void {
		const corsOptions = {
			origin: (env === 'development'
				? [...API_CONFIG.CORS.ORIGINS.DEVELOPMENT] // Convert readonly to mutable array
				: [...API_CONFIG.CORS.ORIGINS.PRODUCTION]
			) as string[], // Explicitly cast to string[]
			allowedHeaders: [...API_CONFIG.CORS.ALLOWED_HEADERS], // Convert readonly to mutable array
			methods: [...API_CONFIG.CORS.METHODS], // Convert readonly to mutable array
			credentials: API_CONFIG.CORS.CREDENTIALS,
		};

		app.use(cors(corsOptions));
		console.log(`✅ CORS configured for ${env} environment.`);
	}


	/**
	 * Create and configure the server (HTTP or HTTPS)
	 */
	private async createServer(): Promise<http.Server | https.Server> {
		let server: http.Server | https.Server;

		if (env === 'development') {
			server = http.createServer(app);
		} else {
			// SSL certificate paths for production
			const privateKeyPath = '/var/keys/privkey.pem';
			const certificatePath = '/var/keys/fullchain.pem';

			const credentials = {
				key: fs.readFileSync(privateKeyPath, 'utf8'),
				cert: fs.readFileSync(certificatePath, 'utf8')
			};

			server = https.createServer(credentials, app);
		}

		// Wrap the listen call with error handling
		server.listen(this.port)
			.on('listening', () => {
				this.logger.info(`Server started on port ${this.port} in ${env} mode`);
			})
			.on('error', (error: NodeJS.ErrnoException) => {
				this.handleServerError(error, server);
			});

		this.setupGlobalErrorHandlers();

		this.logger.info('Global error handlers configured');
		return server;
	}

	/**
	 * Setup global error handlers for uncaught exceptions and rejections
	 */
	private setupGlobalErrorHandlers(): void {
		process.on('uncaughtException', (error) => {
			this.logger.error('Uncaught Exception', error);
			process.exit(1);
		});

		process.on('unhandledRejection', (reason: unknown) => {
			const error = reason instanceof Error ? reason : new Error(String(reason));
			this.logger.error('Unhandled Rejection', error);
		});
	}

	/**
	 * Handle server errors such as 'EADDRINUSE'
	 */
	private handleServerError(error: NodeJS.ErrnoException, server: http.Server | https.Server): void {
		if (error.code === 'EADDRINUSE') {
			this.logger.error(`Port ${this.port} is already in use. Retrying on another port...`, error);
			// Retry with a random port
			server.listen(0);  // 0 means it will assign an available random port
		} else {
			this.logger.error('Error occurred while starting the server:', error);
			throw error;
		}
	}

	/**
	 * Start listening for connections
	 */
	async listen(): Promise<http.Server | https.Server> {
		try {
			await this.init();
			await testFirestoreAccess();

			const server = await this.createServer();
			console.log('Server is now listening for connections');
			if (config.env == 'production') checkSystemOverload();

			return server;
		} catch (error) {
			this.logger.error('Failed to start server', error as Error);
			throw error;
		}
	}
}

// Initialize the AppService and start the server
const appService = AppService.getInstance();
const app = appService.app; // Export the Express app for testing
export { app, appService };



================================================
File: src/_core/server/server.ts
================================================
import 'reflect-metadata'; // Import metadata reflection for TypeDI, 1 time, on top of the app
import { appService} from './app/app.service'
 
appService.listen().catch(error => console.error('Error starting server:', error));



================================================
File: src/models/Contact.model.ts
================================================
// // contact.model.ts
// import { getFirestore } from 'firebase-admin/firestore';

// const db = getFirestore();
// export const contactCollection = db.collection('contacts');


================================================
File: src/models/TradingEconomicsNew.model.ts
================================================
// import { Contact } from "./Contact.model";
// import { CreatedOrUpdatedBy } from "../type/CreatedOrUpdatedBy";

// // Define a type for the createdBy and updatedBy fields


// export class TradingEconomicsNew {
// 	[key: string]: any;  // To allow additional dynamic keys

// 	id?: string;
// 	link?: string;
// 	time?: string;
// 	content?: string;
// 	listContactViewers?: Contact[];
// 	listContactViewersId?: string[];
// 	createdBy?: CreatedOrUpdatedBy[];  // Use the createdBy type for consistency
// 	updatedBy?: CreatedOrUpdatedBy[];  // Same for updatedBy

// 	active?: boolean;
// 	isViewed?: boolean;
// }


================================================
File: src/modules/_base/crud/BaseController.ts
================================================
import { HttpStatusCode } from '@/_core/helper/http-status/common/HttpStatusCode';
import { RestHandler } from '@/_core/helper/http-status/common/RestHandler';
import _ERROR from '@/_core/helper/http-status/error';
import { CustomRequest } from '@/_core/helper/interfaces/CustomRequest.interface';
import { FetchPageResult, PaginationOptions } from '@/_core/helper/interfaces/FetchPageResult.interface';
import { NextFunction, Response } from 'express';
import { Service } from 'typedi';
import { BaseService } from './BaseService';

/**
 * Generic Controller Class for CRUD and Pagination Operations
 */
@Service()
export abstract class BaseController<
    T extends CreateDTO & { id?: string },
    CreateDTO,
    UpdateDTO
> {
    protected service: BaseService<T>;

    constructor(service: BaseService<T>) {
        this.service = service;
    }

    async create(req: CustomRequest<CreateDTO>, res: Response, _next: NextFunction) {
        try {
            const inputData: CreateDTO = req.body;

            const entity = await this.service.create(inputData as Omit<T, 'id'>);

            if (!entity) {
                throw new _ERROR.BadRequestError({
                    message: 'Creation failed',
                });
            }

            return RestHandler.success(req, res, {
                code: HttpStatusCode.CREATED,
                message: 'Entity created successfully',
                data: entity,
                startTime: req.startTime,
            });
        } catch (error) {
            _next(error);
        }
    }
    

    /**
     * ✅ Get all entities
     */
    async getAll(req: CustomRequest, res: Response, _next: NextFunction) {
        try {
            const entities = await this.service.getAll();

            if (!entities || entities.length === 0) {
                throw new _ERROR.NotFoundError({
                    message: 'No entities found',
                });
            }

            return RestHandler.success(req, res, {
                code: HttpStatusCode.OK,
                message: 'Fetched all entities successfully',
                data: entities,
                startTime: req.startTime,
            });
        } catch (error) {
            _next(error);
        }
    }

    /**
     * ✅ Get entity by ID
     */
    async getById(req: CustomRequest, res: Response, _next: NextFunction) {
        try {
            const { id } = req.params;
            const entity = await this.service.getById(id);

            if (!entity) {
                throw new _ERROR.NotFoundError({
                    message: 'Entity not found',
                });
            }

            return RestHandler.success(req, res, {
                code: HttpStatusCode.OK,
                message: 'Fetched entity by ID successfully',
                data: entity,
                startTime: req.startTime,
            });
        } catch (error) {
            _next(error);
        }
    }

    /**
     * ✅ Update an entity by ID
     */
    async update(req: CustomRequest<UpdateDTO>, res: Response, _next: NextFunction) {
        try {
            const { id } = req.params;
            const inputData: UpdateDTO = req.body;
    
            const entity = await this.service.update(id, inputData as unknown as Partial<T>);
    
            if (!entity) {
                throw new _ERROR.NotFoundError({
                    message: 'Entity not found',
                });
            }
    
            return RestHandler.success(req, res, {
                code: HttpStatusCode.OK,
                message: 'Entity updated successfully',
                data: entity as unknown as UpdateDTO,
                startTime: req.startTime,
            });
        } catch (error) {
            _next(error);
        }
    }
    
    
    
    
    

    /**
     * ✅ Delete an entity by ID
     */
    async delete(req: CustomRequest, res: Response, _next: NextFunction) {
        try {
            const { id } = req.params;
            const result = await this.service.delete(id);

            if (!result) {
                throw new _ERROR.NotFoundError({
                    message: 'Entity not found',
                });
            }

            return RestHandler.success(req, res, {
                code: HttpStatusCode.OK,
                message: 'Entity deleted successfully',
                startTime: req.startTime,
            });
        } catch (error) {
            _next(error);
        }
    }

    /**
     * ✅ Paginated Query
     */
    async paginator(req: CustomRequest, res: Response, _next: NextFunction) {
        try {
            const { page = '1', limit = '10', all = 'false' } = req.query;
            const options: PaginationOptions = {
                page: Number(page),
                limit: Number(limit),
                all: all === 'true',
            };

            const paginationResult: FetchPageResult<T> = await this.service.paginator(options);

            return RestHandler.success(req, res, {
                code: HttpStatusCode.OK,
                message: 'Fetched paginated entities successfully',
                data: paginationResult,
                startTime: req.startTime,
            });
        } catch (error) {
            _next(error);
        }
    }
}


================================================
File: src/modules/_base/crud/BaseRepository.ts
================================================
import { firestore } from '@/_core/database/firebase-admin-sdk';
import { createPagination } from '@/_core/helper/http-status/common/create-pagination';
import _ERROR from '@/_core/helper/http-status/error';
import { FetchPageResult, PaginationOptions } from '@/_core/helper/interfaces/FetchPageResult.interface';
import { Query } from 'firebase-admin/firestore';

/**
 * ✅ Generic Firestore Repository
 */
export abstract class BaseRepository<T extends { id?: string }> {
    protected collectionName: string;

    constructor(collectionName: string) {
        this.collectionName = collectionName;
    }

    /**
     * ✅ Access Firestore Collection
     */
    protected get collection(): FirebaseFirestore.CollectionReference {
        return firestore.collection(this.collectionName);
    }

    /**
     * ✅ Create a new document
     */
    async create(data: Omit<T, 'id'>): Promise<T> {
        try {
            const docRef = await this.collection.add({
                ...data,
                createdAt: new Date(),
                updatedAt: new Date(),
            });
            return { id: docRef.id, ...data } as T;
        } catch (error: any) {
            this.handleFirestoreError(error, 'Failed to create document');
        }
    }

    /**
     * ✅ Create a document with a specific ID
     */
    async createWithId(id: string, data: Omit<T, 'id'>): Promise<T> {
        try {
            await this.collection.doc(id).set({
                ...data,
                createdAt: new Date(),
                updatedAt: new Date(),
            });
            return { id, ...data } as T;
        } catch (error: any) {
            this.handleFirestoreError(error, 'Failed to create document with ID');
        }
    }

    /**
     * ✅ Fetch all documents
     */
    async findAll(): Promise<T[]> {
        try {
            const snapshot = await this.collection.get();
            return snapshot.docs.map((doc) => ({
                id: doc.id,
                ...doc.data(),
            })) as T[];
        } catch (error: any) {
            this.handleFirestoreError(error, 'Failed to fetch documents');
        }
    }

    /**
     * ✅ Find a document by ID
     */
    async findById(id: string): Promise<T | null> {
        try {
            console.log(`🔍 Fetching document with ID: ${id}`);

            const docRef = this.collection.doc(id);
            const doc = await docRef.get();

            console.log(`📄 Document Snapshot Exists: ${doc.exists}`);

            if (!doc.exists) {
                console.warn(`⚠️ Document with ID: ${id} does not exist`);
                throw new _ERROR.NotFoundError({ message: `Document with ID ${id} not found` });
            }

            console.log(`✅ Document found:`, doc.data());
            return { id: doc.id, ...doc.data() } as T;
        } catch (error: any) {
            if (error instanceof _ERROR.NotFoundError) {
                throw error;
            }
            this.handleFirestoreError(error, `Failed to fetch document with ID ${id}`);
        }
    }

    /**
     * ✅ Update a document by ID
     */
    async update(id: string, updates: Partial<T>): Promise<T | null> {
        try {
            const docRef = this.collection.doc(id);
            const doc = await docRef.get();

            if (!doc.exists) {
                console.warn(`⚠️ Document with ID: ${id} does not exist`);
                throw new _ERROR.NotFoundError({ message: `Document with ID ${id} not found` });
            }

            await docRef.update({
                ...updates,
                updatedAt: new Date(),
            });

            const updatedDoc = await docRef.get();
            return { id: updatedDoc.id, ...updatedDoc.data() } as T;
        } catch (error: any) {
            if (error instanceof _ERROR.NotFoundError) {
                throw error;
            }
            this.handleFirestoreError(error, `Failed to update document with ID ${id}`);
        }
    }

    /**
     * ✅ Delete a document by ID
     */
    async delete(id: string): Promise<boolean> {
        try {
            const docRef = this.collection.doc(id);
            const doc = await docRef.get();

            if (!doc.exists) {
                console.warn(`⚠️ Document with ID: ${id} does not exist`);
                throw new _ERROR.NotFoundError({ message: `Document with ID ${id} not found` });
            }

            await docRef.delete();
            return true;
        } catch (error: any) {
            if (error instanceof _ERROR.NotFoundError) {
                throw error;
            }
            this.handleFirestoreError(error, `Failed to delete document with ID ${id}`);
        }
    }

    /**
     * ✅ Paginated Query
     */
    async paginator(options: PaginationOptions): Promise<FetchPageResult<T>> {
        try {
            const {
                page = 1,
                limit = 10,
                filters = [],
                lastVisible,
                orderBy,
                all = false,
            } = options;

            let query: Query = this.collection;

            // Apply filters
            for (const filter of filters) {
                query = query.where(filter.key, filter.operator, filter.value);
            }

            // Apply sorting
            if (orderBy) {
                query = query.orderBy(orderBy.field, orderBy.direction || 'asc');
            }

            // Apply pagination
            if (!all) {
                if (lastVisible) {
                    query = query.startAfter(lastVisible);
                }
                query = query.limit(limit);
            }

            const snapshot = await query.get();
            const data = snapshot.docs.map((doc) => ({
                id: doc.id,
                ...doc.data(),
            })) as T[];

            const totalSnapshot = await firestore.collection(this.collectionName).count().get();
            const totalItems = totalSnapshot.data()?.count || 0;

            return createPagination<T>(data, totalItems, page, limit);
        } catch (error: any) {
            this.handleFirestoreError(error, 'Failed to paginate documents');
        }
    }

    /**
     * ✅ Unified Error Handling
     */
    private handleFirestoreError(error: any, defaultMessage: string): never {
        console.error('❌ Firestore Error:', error);

        if (error instanceof _ERROR.NotFoundError) {
            throw error;
        }

        switch (error.code) {
            case 'permission-denied':
                throw new _ERROR.ForbiddenError({ message: 'Permission denied' });
            case 'not-found':
                throw new _ERROR.NotFoundError({ message: 'Resource not found' });
            default:
                throw new _ERROR.InternalServerError({
                    message: defaultMessage,
                    error: error.message || 'Unknown Firestore error',
                });
        }
    }
}


================================================
File: src/modules/_base/crud/BaseService.ts
================================================
import { FetchPageResult, PaginationOptions } from '@/_core/helper/interfaces/FetchPageResult.interface';
import { BaseRepository } from './BaseRepository';

/**
 * Generic Service Class for CRUD Operations
 */
export abstract class BaseService<T extends { id?: string }> {
  protected repository: BaseRepository<T>;

  constructor(repository: BaseRepository<T>) {
    this.repository = repository;
  }

  async create(data: Omit<T, 'id'>): Promise<T | false> {
    return await this.repository.create(data);
  }

  async createWithId(id: string, data: Omit<T, 'id'>): Promise<T> {
    return await this.repository.createWithId(id, data);
  }

  async getAll(): Promise<T[]> {
    return await this.repository.findAll();
  }

  async getById(id: string): Promise<T | null> {
    try {
      return await this.repository.findById(id);
    } catch (error) {
      console.error(`Error getting with ID ${id}:`, error);
      throw error;
    }
  }

  async update(id: string, updates: Partial<T>): Promise<T | null> {
    return await this.repository.update(id, updates);
  }

  async delete(id: string): Promise<boolean> {
    return await this.repository.delete(id);
  }

  async paginator(options: PaginationOptions): Promise<FetchPageResult<T>> {
    return await this.repository.paginator(options);
  }
}


================================================
File: src/modules/contact/__tests__/contact-controller.spec.ts
================================================
import { Request, Response, NextFunction } from 'express';
import ContactController from '../contact.controller';
import ContactService from '../contact.service';
import { HttpStatusCode } from '@/_core/helper/http-status/common/HttpStatusCode';
import { RestHandler } from '@/_core/helper/http-status/common/RestHandler';
import { IContact } from '../contact.interface';
import ContactRepository from '../contact.repository';

jest.mock('../contact.service');
jest.mock('@/_core/helper/http-status/common/RestHandler');

describe('ContactController', () => {
  let contactController: ContactController;
  let mockContactService: jest.Mocked<ContactService>;
  let mockContactRepository: jest.Mocked<ContactRepository>;
  let req: Partial<Request>;
  let res: Partial<Response>;
  let next: NextFunction;

  beforeEach(() => {
    mockContactRepository = new ContactRepository() as jest.Mocked<ContactRepository>;
    mockContactService = new ContactService(mockContactRepository) as jest.Mocked<ContactService>;
    contactController = new ContactController(mockContactService);

    req = {
      params: {},
      body: {},
    };
    res = {
      status: jest.fn().mockReturnThis(),
      json: jest.fn(),
    };
    next = jest.fn();

    jest.clearAllMocks();
  });

  // ✅ Test create
  it('should create a new contact', async () => {
    req.body = {
      name: 'John Doe',
      email: 'john@example.com',
      phone: '1234567890',
      message: 'Test message',
    };

    const mockContact: IContact = {
      id: '1',
      ...req.body,
    };

    mockContactService.create.mockResolvedValue(mockContact);

    await contactController.create(req as any, res as Response, next);

    expect(mockContactService.create).toHaveBeenCalledWith(req.body);
    expect(RestHandler.success).toHaveBeenCalledWith(req, res, {
      code: HttpStatusCode.CREATED,
      message: 'Contact created successfully',
      data: mockContact,
    });
  });

  it('should handle failure to create a contact', async () => {
    req.body = {
      name: 'Invalid Contact',
    };

    mockContactService.create(req.body);

    await contactController.create(req as any, res as Response, next);

    expect(mockContactService.create).toHaveBeenCalledWith(req.body);
    expect(RestHandler.error).toHaveBeenCalledWith(req, res, {
      code: HttpStatusCode.BAD_REQUEST,
      message: 'Contact creation failed',
    });
  });

  // ✅ Test getAll
  it('should return all contacts', async () => {
    const mockContacts: IContact[] = [
      { id: '1', firstName: 'John', lastName: 'Doe', email: 'john@example.com', phone: '1234567890', message: 'Test message' },
    ];

    mockContactService.getAll.mockResolvedValue(mockContacts);

    await contactController.getAll(req as any, res as Response, next);

    expect(mockContactService.getAll).toHaveBeenCalled();
    expect(RestHandler.success).toHaveBeenCalledWith(req, res, {
      code: HttpStatusCode.OK,
      message: 'Get all contacts successfully',
      data: mockContacts,
    });
  });

  it('should handle no contacts found', async () => {
    mockContactService.getAll.mockResolvedValue([]);

    await contactController.getAll(req as any, res as Response, next);

    expect(RestHandler.success).toHaveBeenCalledWith(req, res, {
      code: HttpStatusCode.NO_CONTENT,
      message: 'Get all contacts successfully',
      data: [],
    });
  });

  // ✅ Test getById
  it('should return a contact by ID', async () => {
    if (req.params === undefined) {
      throw new Error('Missing required parameter: id');
    }
    req.params.id = '1';

    const mockContact: IContact = {
      id: '1',
      firstName: 'John',
      lastName: 'Doe',
      email: 'john@example.com',
      phone: '1234567890',
      message: 'Test message',
    };

    mockContactService.getById.mockResolvedValue(mockContact);

    await contactController.getById(req as any, res as Response, next);

    expect(mockContactService.getById).toHaveBeenCalledWith('1');
    expect(RestHandler.success).toHaveBeenCalledWith(req, res, {
      code: HttpStatusCode.OK,
      message: 'Get contact by id successfully',
      data: mockContact,
    });
  });

  it('should return 404 when contact is not found', async () => {
    if (req.params === undefined) {
      throw new Error('Missing required parameter: id');
    }
    req.params.id = '1';

    mockContactService.getById.mockResolvedValue(null);

    await contactController.getById(req as any, res as Response, next);

    expect(mockContactService.getById).toHaveBeenCalledWith('1');
    expect(RestHandler.error).toHaveBeenCalledWith(req, res, {
      code: HttpStatusCode.NOT_FOUND,
      message: 'Contact not found',
    });
  });

  // ✅ Test update
  it('should update a contact successfully', async () => {
     if (req.params === undefined) {
      throw new Error('Missing required parameter: id');
    }
    req.params.id = '1';
    req.body = {
      name: 'Updated Name',
      email: 'updated@example.com',
      phone: '9876543210',
      message: 'Updated message',
    };

    const updatedContact: IContact = {
      id: '1',
      firstName: 'Updated',
      lastName: 'Name',
      email: 'updated@example.com',
      phone: '9876543210',
      message: 'Updated message',
    };

    mockContactService.update.mockResolvedValue(updatedContact);

    await contactController.update(req as any, res as Response, next);

    expect(mockContactService.update).toHaveBeenCalledWith('1', req.body);
    expect(RestHandler.success).toHaveBeenCalledWith(req, res, {
      code: HttpStatusCode.OK,
      message: 'Update contact successfully',
      data: updatedContact,
    });
  });

  it('should return 404 when contact is not found', async () => {
     if (req.params === undefined) {
      throw new Error('Missing required parameter: id');
    }
    req.params.id = '1';
    req.body = {
      firstName: 'Updated',
      lastName: 'Name',
      email: 'updated@example.com',
      phone: '9876543210',
      message: 'Updated message',
    };

    mockContactService.update.mockResolvedValue(null);

    await contactController.update(req as any, res as Response, next);

    expect(mockContactService.update).toHaveBeenCalledWith('1', req.body);
    expect(RestHandler.error).toHaveBeenCalledWith(req, res, {
      code: HttpStatusCode.NOT_FOUND,
      message: 'Contact not found',
    });
  });

  // ✅ Test delete
  it('should delete a contact', async () => {
    if (req.params === undefined) {
      throw new Error('Missing required parameter: id');
    }
    req.params.id = '1';

    mockContactService.delete.mockResolvedValue(true);

    await contactController.delete(req as any, res as Response, next);

    expect(mockContactService.delete).toHaveBeenCalledWith('1');
    expect(RestHandler.success).toHaveBeenCalledWith(req, res, {
      code: HttpStatusCode.OK,
      message: 'Delete contact successfully',
    });
  });

  it('should handle delete failure', async () => {
    if (req.params === undefined) {
      throw new Error('Missing required parameter: id');
    }
    req.params.id = '1';

    mockContactService.delete.mockResolvedValue(false);

    await contactController.delete(req as any, res as Response, next);

    expect(mockContactService.delete).toHaveBeenCalledWith('1');
    expect(RestHandler.error).toHaveBeenCalledWith(req, res, {
      code: HttpStatusCode.NOT_FOUND,
      message: 'Contact not found',
    });
  });
});


================================================
File: src/modules/contact/__tests__/contact.handle.spec.ts
================================================
import { createHandler } from '../contact.handler';

jest.mock('@/_core/helper/validateZodSchema', () => ({
  validateSchema: jest.fn().mockImplementation(() => {
    return (req: any) => {
      if (!req.body.name) {
        const error = new Error('Name is required');
        throw error;
      }
    };
  }),
}));

jest.mock('../contact.controller.factory', () => ({
  __esModule: true,
  default: {
    createContact: jest.fn().mockImplementation((_req, res) => {
      res.status(201).json({
        id: '123',
        message: 'Contact created',
      });
    }),
  },
}));

describe('Contact Handler', () => {
  let mockRequest: any;
  let mockResponse: any;
  let mockNext: any;

  beforeEach(() => {
    mockRequest = {
      body: {
        name: 'John Doe',
        email: 'john@example.com',
        phone: '1234567890',
        message: 'Test message',
      },
    };

    mockResponse = {
      status: jest.fn().mockReturnThis(),
      json: jest.fn(),
      headersSent: false,
    };

    mockNext = jest.fn();

    jest.clearAllMocks();
  });

  // ✅ Test: Successful Contact Creation
  describe('createContact', () => {
    it('should validate the request and pass to controller', async () => {
      const mockController = require('../contact.controller.factory').default;

      await createHandler(mockRequest, mockResponse, mockNext);

      expect(mockNext).not.toHaveBeenCalled();
      expect(mockController.createContact).toHaveBeenCalled();
      expect(mockResponse.status).toHaveBeenCalledWith(201);
      expect(mockResponse.json).toHaveBeenCalledWith({
        id: '123',
        message: 'Contact created',
      });
    });

    // ✅ Test: Validation Error
    it('should handle validation errors', async () => {
      delete mockRequest.body.name;

      try {
        await createHandler(mockRequest, mockResponse, mockNext);
      } catch (error: any) {
        expect(error.message).toBe('Name is required');
      }
    });

    // ✅ Test: Controller Throws Error
    it('should handle errors from the controller', async () => {
      const mockController = require('../contact.controller.factory').default;
      
      mockController.createContact.mockImplementation(() => {
        throw new Error('Controller Error');
      });

      await expect(createHandler(mockRequest, mockResponse, mockNext)).rejects.toThrow('Controller Error');

      expect(mockController.createContact).toHaveBeenCalled();
    });

    // ✅ Test: Invalid Email Format
    it('should handle invalid email format gracefully', async () => {
      mockRequest.body.email = 'invalid-email';

      jest.mocked(require('@/_core/helper/validateZodSchema').validateSchema).mockImplementation(() => {
        throw new Error('Invalid email format');
      });

      try {
        await createHandler(mockRequest, mockResponse, mockNext);
      } catch (error: any) {
        expect(error.message).toBe('Invalid email format');
      }
    });

    // ✅ Test: Missing Phone Field
    it('should handle missing phone field', async () => {
      delete mockRequest.body.phone;

      jest.mocked(require('@/_core/helper/validateZodSchema').validateSchema).mockImplementation(() => {
        throw new Error('Phone is required');
      });

      try {
        await createHandler(mockRequest, mockResponse, mockNext);
      } catch (error: any) {
        expect(error.message).toBe('Phone is required');
      }
    });

    // ✅ Test: Missing Email Field
    it('should handle missing email field', async () => {
      delete mockRequest.body.email;

      jest.mocked(require('@/_core/helper/validateZodSchema').validateSchema).mockImplementation(() => {
        throw new Error('Email is required');
      });

      try {
        await createHandler(mockRequest, mockResponse, mockNext);
      } catch (error: any) {
        expect(error.message).toBe('Email is required');
      }
    });
  });
});


================================================
File: src/modules/contact/__tests__/contact.repository.spec.ts
================================================
import ContactRepository from '../contact.repository';
import { IContact } from '../contact.interface';
import { firestore } from '@/_core/database/firebase-admin-sdk';

// ✅ Proper Firestore Mocking
jest.mock('@/_core/database/firebase', () => ({
  firestore: {
    collection: jest.fn(() => ({
      add: jest.fn(),
      get: jest.fn(),
      doc: jest.fn(() => ({
        get: jest.fn(),
        update: jest.fn(),
        delete: jest.fn(),
      })),
    })),
  },
}));

// ✅ TypeScript Type for Mocked Firestore
const mockFirestore = firestore as unknown as {
  collection: jest.Mock<
    {
      add: jest.Mock;
      get: jest.Mock;
      doc: jest.Mock<{
        get: jest.Mock;
        update: jest.Mock;
        delete: jest.Mock;
      }>;
    },
    [string]
  >;
};

describe('ContactRepository', () => {
  let contactRepository: ContactRepository;

  beforeEach(() => {
    contactRepository = new ContactRepository();
    jest.clearAllMocks();
  });

  // ✅ Test: Create a New Contact
  it('should create a new contact', async () => {
    const contactData: IContact = {
      firstName: 'John',
      lastName: 'Doe',
      email: 'john@example.com',
      phone: '1234567890',
      message: 'Test message',
    };

    mockFirestore.collection.mockReturnValue({
      add: jest.fn().mockResolvedValue({ id: '123' }),
      get: jest.fn(),
      doc: jest.fn(),
    });

    const result = await contactRepository.create(contactData);

    expect(mockFirestore.collection).toHaveBeenCalledWith('contacts');
    expect(mockFirestore.collection('contact').add).toHaveBeenCalledWith({
      ...contactData,
      createdAt: expect.any(Date),
      updatedAt: expect.any(Date),
    });
    expect(result).toEqual({ id: '123', ...contactData });
  });

  // ✅ Test: Find All Contacts
  it('should fetch all contacts', async () => {
    const mockSnapshot = {
      docs: [
        {
          id: '1',
          data: () => ({
            name: 'Jane Doe',
            email: 'jane@example.com',
            phone: '1234567890',
            message: 'Hello',
          }),
        },
      ],
    };

    mockFirestore.collection.mockReturnValue({
      get: jest.fn().mockResolvedValue(mockSnapshot),
      add: jest.fn(),
      doc: jest.fn(),
    });

    const result = await contactRepository.findAll();

    expect(mockFirestore.collection).toHaveBeenCalledWith('contacts');
    expect(mockFirestore.collection('contact').get).toHaveBeenCalled();
    expect(result).toEqual([
      {
        id: '1',
        name: 'Jane Doe',
        email: 'jane@example.com',
        phone: '1234567890',
        message: 'Hello',
      },
    ]);
  });

  // ✅ Test: Find Contact by ID
  it('should fetch a contact by ID', async () => {
    const mockDoc = {
      exists: true,
      id: '1',
      data: () => ({
        name: 'Jane Doe',
        email: 'jane@example.com',
        phone: '1234567890',
        message: 'Hello',
      }),
    };

    mockFirestore.collection.mockReturnValue({
      doc: jest.fn().mockReturnValue({
        get: jest.fn().mockResolvedValue(mockDoc),
      }),
      add: jest.fn(),
      get: jest.fn(),
    });

    const result = await contactRepository.findById('1');

    expect(mockFirestore.collection).toHaveBeenCalledWith('contacts');
    expect(mockFirestore.collection('contact').doc).toHaveBeenCalledWith('1');
    expect(mockFirestore.collection('contact').doc().get).toHaveBeenCalled();
    expect(result).toEqual({
      id: '1',
      name: 'Jane Doe',
      email: 'jane@example.com',
      phone: '1234567890',
      message: 'Hello',
    });
  });

  // ✅ Test: Update Contact by ID
  it('should update a contact by ID', async () => {
    const updatedData = {
      name: 'Jane Doe Updated',
      email: 'jane@example.com',
      phone: '1234567890',
      message: 'Updated message',
    };

    mockFirestore.collection.mockReturnValue({
      doc: jest.fn().mockReturnValue({
        update: jest.fn().mockResolvedValue(undefined),
        get: jest.fn().mockResolvedValue({
          exists: true,
          id: '1',
          data: () => updatedData,
        }),
      }),
      add: jest.fn(),
      get: jest.fn(),
    });

    const result = await contactRepository.update('1', updatedData);

    expect(mockFirestore.collection).toHaveBeenCalledWith('contacts');
    expect(mockFirestore.collection('contact').doc).toHaveBeenCalledWith('1');
    expect(mockFirestore.collection('contact').doc().update).toHaveBeenCalledWith({
      ...updatedData,
      updatedAt: expect.any(Date),
    });
    expect(result).toEqual({
      id: '1',
      ...updatedData,
    });
  });

  // ✅ Test: Delete Contact by ID
  it('should delete a contact by ID', async () => {
    mockFirestore.collection.mockReturnValue({
      doc: jest.fn().mockReturnValue({
        delete: jest.fn().mockResolvedValue(undefined),
      }),
      add: jest.fn(),
      get: jest.fn(),
    });

    const result = await contactRepository.delete('1');

    expect(mockFirestore.collection).toHaveBeenCalledWith('contacts');
    expect(mockFirestore.collection('contact').doc).toHaveBeenCalledWith('1');
    expect(mockFirestore.collection('contact').doc().delete).toHaveBeenCalled();
    expect(result).toBe(true);
  });
});


================================================
File: src/modules/contact/__tests__/contact.route.spec.ts
================================================
// src/modules/contact/__tests__/contact.route.spec.ts
import { app } from '@/_core/server/app/app.service';
import http from 'http';
import { createRouter } from '@node_modules/express-route-tracker/dist';

jest.mock('express-rate-limit');
jest.mock('helmet'); 
jest.mock('express-route-tracker/dist');
jest.mock('@/_core/database/firebase');

let server: http.Server;

beforeAll((done) => {
 server = app.listen(4000, done);
});

afterAll((done) => {
 server.close(done);
});

describe('Contact Routes', () => {
 beforeEach(() => {
   jest.clearAllMocks();
   require('../index');
   
   const mockRouter = createRouter(__filename);
   expect(mockRouter.post).toBeDefined();
   expect(mockRouter.get).toBeDefined();
   expect(mockRouter.put).toBeDefined();
   expect(mockRouter.delete).toBeDefined();
 });

 it('should have route handlers defined', () => {
   expect(createRouter).toHaveBeenCalledWith(__filename);
 });
});

================================================
File: src/modules/contact/__tests__/contact.service.spec.ts
================================================
// __tests__/contact.service.spec.ts
import ContactService from '../contact.service';
import ContactRepository from '../contact.repository';

describe('ContactService', () => {
  let contactService: ContactService;
  let mockContactRepository: jest.Mocked<ContactRepository>;

  beforeEach(() => {
    mockContactRepository = {
      create: jest.fn(),
      findAll: jest.fn(),
      findById: jest.fn(),
      update: jest.fn(),
      delete: jest.fn(),
    } as any;

    contactService = new ContactService(mockContactRepository);
    jest.clearAllMocks();
  });

  it('should create a new contact', async () => {
    const contactData = { name: 'John', email: 'john@example.com', phone: '1234567890' };
    mockContactRepository.create.mockResolvedValue({ id: '1', ...contactData });

    const result = await contactService.createContact(contactData);

    expect(mockContactRepository.create).toHaveBeenCalledWith(contactData);
    expect(result).toEqual({ id: '1', ...contactData });
  });

  it('should fetch all contacts', async () => {
    const contacts = [{ id: '1', name: 'John', email: 'john@example.com', phone: '1234567890' }];
    mockContactRepository.findAll.mockResolvedValue(contacts);

    const result = await contactService.getAllContacts();

    expect(mockContactRepository.findAll).toHaveBeenCalled();
    expect(result).toEqual(contacts);
  });

  it('should fetch a contact by ID', async () => {
    const contact = { id: '1', name: 'John', email: 'john@example.com', phone: '1234567890' };
    mockContactRepository.findById.mockResolvedValue(contact);

    const result = await contactService.getContactById('1');

    expect(mockContactRepository.findById).toHaveBeenCalledWith('1');
    expect(result).toEqual(contact);
  });

  it('should update a contact by ID', async () => {
    const updatedContact = { id: '1', name: 'John Updated', email: 'john@example.com', phone: '1234567890' };
    mockContactRepository.update.mockResolvedValue(updatedContact);

    const result = await contactService.updateContact('1', updatedContact);

    expect(mockContactRepository.update).toHaveBeenCalledWith('1', updatedContact);
    expect(result).toEqual(updatedContact);
  });

  it('should delete a contact by ID', async () => {
    mockContactRepository.delete.mockResolvedValue(true);

    const result = await contactService.deleteContact('1');

    expect(mockContactRepository.delete).toHaveBeenCalledWith('1');
    expect(result).toBe(true);
  });
});


================================================
File: src/modules/contact/contact.controller.ts
================================================
import { Service } from 'typedi';
import ContactService from './contact.service';
import { IContact } from './contact.interface';
import { CreateInput, UpdateInput } from './contact.dto';
import { BaseController } from '../_base/crud/BaseController';

@Service()
class ContactController extends BaseController<IContact, CreateInput, UpdateInput> {
  constructor(service: ContactService) {
    super(service);
  }  
}

export default ContactController;


================================================
File: src/modules/contact/contact.dto.ts
================================================
import { z } from "zod";
import { CreateSchema, UpdateSchema, IdSchema } from "./contact.validation";

export type CreateInput = z.infer<typeof CreateSchema>;
export type UpdateInput = z.infer<typeof UpdateSchema>;
export type IdInput = z.infer<typeof IdSchema>;

================================================
File: src/modules/contact/contact.handler.ts
================================================
import { validateDTO } from "@/_core/helper/validateZodSchema";
import { NextFunction, Request, Response } from 'express';
import { contactController } from "./contact.module";
import { IdSchema, CreateSchema, UpdateSchema } from "./contact.validation";


const validateCreateDTO = validateDTO(CreateSchema, 'body');
const validateIdDTO = validateDTO(IdSchema, 'params');
const validateUpdateDTO = validateDTO(UpdateSchema, 'body');

/**
 * Create Handler
 */
const createHandler = async (req: Request, res: Response, next: NextFunction) => {
  try {
    // Validation already happened in middleware
    await contactController.create(req, res, next);
  } catch (error) {
    next(error);
  }
};

/**
 * Get All Handler
 */
const getAllsHandler = async (req: Request, res: Response, next: NextFunction): Promise<any> => {
  try {
    await contactController.getAll(req, res, next);
  } catch (error) {
    next(error);
  }
};

/**
 * Get By ID Handler
 */
const getByIdHandler = async (req: Request, res: Response, next: NextFunction) => {
  try {
    await contactController.getById(req, res, next);
  } catch (error) {
    next(error);
  }
}

/**
 * Update Handler
 */
const updateHandler = async (req: Request, res: Response, next: NextFunction) => {
  try {
    await contactController.update(req, res, next);
  } catch (error) {
    next(error);
  }
}

/**
 * Delete Handler
 */
const deleteHandler = async (req: Request, res: Response, next: NextFunction) => {
  try {
    await contactController.delete(req, res, next);
  } catch (error) {
    next(error);
  }
}

export {
  validateCreateDTO,
  validateIdDTO,
  validateUpdateDTO,
  createHandler,
  deleteHandler,
  getAllsHandler,
  getByIdHandler,
  updateHandler
};


================================================
File: src/modules/contact/contact.interface.ts
================================================
// contact.interface.ts
export interface IContact {
  id?: string;
  firstName: string;
  lastName: string;
  email: string;
  phone: string;
  address?: string;
  postalCode?: string;
  city?: string;
  country?: string;
  message?: string;
  createdAt?: Date;
  updatedAt?: Date;
}


================================================
File: src/modules/contact/contact.module.ts
================================================
import { Container } from 'typedi';
import ContactController from './contact.controller';
import ContactService from './contact.service';
import ContactRepository from './contact.repository';

class ContactModule {
    public contactController: ContactController;
    public contactService: ContactService;
    public contactRepository: ContactRepository;

    constructor() {
        this.contactController = Container.get(ContactController);
        this.contactService = Container.get(ContactService);
        this.contactRepository = Container.get(ContactRepository);
    }
}

const contactModule = new ContactModule();

export const { contactController, contactService, contactRepository } = contactModule;

================================================
File: src/modules/contact/contact.repository.ts
================================================
// contact.repository.ts
import { Service } from 'typedi';
import { BaseRepository } from '../_base/crud/BaseRepository';
import { IContact } from './contact.interface';

@Service()
export class ContactRepository extends BaseRepository<IContact> {
  constructor() {
    super('contacts');
  }
}
export default ContactRepository;


================================================
File: src/modules/contact/contact.service.ts
================================================
// contact.service.ts
import ContactRepository from './contact.repository';
import { IContact } from './contact.interface';
import { Service } from 'typedi';
import { BaseService } from '../_base/crud/BaseService';

@Service()
class ContactService extends BaseService<IContact> {
  constructor(repository: ContactRepository) {
    super(repository);
  }

  // ✅ You can add Contact-specific methods here
  // async getContactsByStatus(status: string): Promise<IContact[]> {
  //   const allContacts = await this.getAll();
  //   return allContacts.filter((contact) => contact.status === status);
}

export default ContactService;

================================================
File: src/modules/contact/contact.validation.ts
================================================
// contact.validation.ts
import { z } from 'zod';

export const CreateSchema = z.object({
  firstName: z.string().min(1, 'First name is required'),
  lastName: z.string().min(1, 'Last name is required'),
  email: z.string().email('Invalid email format'),
  phone: z.string().min(10, 'Phone must be at least 10 digits'),
  address: z.string().optional(),
  postalCode: z.string().optional(),
  city: z.string().optional(),
  country: z.string().optional(),
  message: z.string().optional(),
});

export const UpdateSchema = z.object({
  firstName: z.string().min(1, 'First name is required').optional(),
  lastName: z.string().min(1, 'Last name is required').optional(),
  email: z.string().email('Invalid email format').optional(),
  phone: z.string().min(10, 'Phone must be at least 10 digits').optional(),
  address: z.string().optional(),
  postalCode: z.string().optional(),
  city: z.string().optional(),
  country: z.string().optional(),
  message: z.string().optional(),
});

export const IdSchema = z.object({
  id: z.string().min(1, 'ID is required'),
});




================================================
File: src/modules/contact/index.ts
================================================
// src\modules\contact\index.ts
import { createHATEOASMiddleware, createRouter } from 'express-route-tracker';
import {
  createHandler,
  deleteHandler,
  getAllsHandler,
  getByIdHandler,
  updateHandler,
  validateCreateDTO,
  validateIdDTO,
  validateUpdateDTO
} from './contact.handler';
import { asyncHandler } from '@/_core/helper/asyncHandler';
import { config } from '@/_core/config/dotenv.config';

// Create router with source tracking
const router = createRouter(__filename);

router.use(createHATEOASMiddleware(router, {
  autoIncludeSameRoute: true,
  baseUrl: config.baseUrl,
  includePagination: true,
  customLinks: {
      documentation: (_req) => ({
          rel: 'documentation',
          href: config.baseUrl+'/docs',
          method: 'GET',
          'title': 'API Documentation'
      })
  }
}));

// Define routes without baseApi prefix
router.post('/', validateCreateDTO, asyncHandler(createHandler));
router.get('/', asyncHandler(getAllsHandler));
router.get('/:id', validateIdDTO, asyncHandler(getByIdHandler));
router.put('/:id', validateIdDTO, validateCreateDTO, asyncHandler(updateHandler));
router.patch('/:id', validateIdDTO, validateUpdateDTO, asyncHandler(updateHandler));
router.delete('/:id', validateIdDTO, asyncHandler(deleteHandler));

export = router;


================================================
File: src/modules/index.ts
================================================
//src\modules\index.ts
import { firebaseAuthMiddleware } from '@/_core/middleware/auth.middleware';
import { NextFunction, Request, Response, Router } from 'express';

const router = Router();
router.post('/', (_req: Request, res: Response, _next: NextFunction) => {
	return res.status(200).json({
		message: 'Welcome to AIAnalyst!'
	})
});

// Auth routes - these should be protected except login/register
router.use('/api/auth', require('../_core/auth'));

router.use('/api/contact', firebaseAuthMiddleware, require('./contact'));
router.use('/api/trading-economics-new', firebaseAuthMiddleware, require('./trading-economics-new'));

// router.use('/v1/api/error', require('./error'));




export default router;

================================================
File: src/modules/trading-economics-new/index.ts
================================================
// src\modules\trading-economics-new\index.ts
import { createHATEOASMiddleware, createRouter } from 'express-route-tracker';
import {
  createHandler,
  deleteHandler,
  getAllsHandler,
  getByIdHandler,
  updateHandler,
  validateCreateDTO,
  validateIdDTO,
  validateUpdateDTO
} from './trading-economics-new.handler';
import { asyncHandler } from '@/_core/helper/asyncHandler';
import { config } from '@/_core/config/dotenv.config';

// Create router with source tracking
const router = createRouter(__filename);

router.use(createHATEOASMiddleware(router, {
  autoIncludeSameRoute: true,
  baseUrl: config.baseUrl,
  includePagination: true,
  customLinks: {
      documentation: (_req) => ({
          rel: 'documentation',
          href: config.baseUrl+'/docs',
          method: 'GET',
          'title': 'API Documentation'
      })
  }
}));

// Define routes without baseApi prefix
router.post('/', validateCreateDTO, asyncHandler(createHandler));
router.get('/', asyncHandler(getAllsHandler));
router.get('/:id', validateIdDTO, asyncHandler(getByIdHandler));
router.put('/:id', validateIdDTO, validateCreateDTO, asyncHandler(updateHandler));
router.patch('/:id', validateIdDTO, validateUpdateDTO, asyncHandler(updateHandler));
router.delete('/:id', validateIdDTO, asyncHandler(deleteHandler));

export = router;


================================================
File: src/modules/trading-economics-new/trading-economics-new.controller.ts
================================================
import { Service } from 'typedi';
import { BaseController } from '../_base/crud/BaseController';
import TradingEconomicsNewService from './trading-economics-new.service';
import { ITradingEconomicsNew } from './trading-economics-new.interface';
import { CreateInput, UpdateInput } from './trading-economics-new.dto';

@Service()
class TradingEconomicsNewController extends BaseController<ITradingEconomicsNew, CreateInput, UpdateInput> {
  constructor(service: TradingEconomicsNewService) {
    super(service);
  }  
}

export default TradingEconomicsNewController;


================================================
File: src/modules/trading-economics-new/trading-economics-new.dto.ts
================================================
import { z } from "zod";
import { CreateSchema, UpdateSchema, IdSchema } from "./trading-economics-new.validation";

export type CreateInput = z.infer<typeof CreateSchema>;
export type UpdateInput = z.infer<typeof UpdateSchema>;
export type IdInput = z.infer<typeof IdSchema>;

================================================
File: src/modules/trading-economics-new/trading-economics-new.handler.ts
================================================
import { validateDTO } from "@/_core/helper/validateZodSchema";
import { NextFunction, Request, Response } from 'express';
import { IdSchema, CreateSchema, UpdateSchema } from "./trading-economics-new.validation";
import { tradingEconomicsNewController } from "./trading-economics-new.module";


const validateCreateDTO = validateDTO(CreateSchema, 'body');
const validateIdDTO = validateDTO(IdSchema, 'params');
const validateUpdateDTO = validateDTO(UpdateSchema, 'body');

/**
 * Create Handler
 */
const createHandler = async (req: Request, res: Response, next: NextFunction) => {
  try {
    // Validation already happened in middleware
    await tradingEconomicsNewController.create(req, res, next);
  } catch (error) {
    next(error);
  }
};

/**
 * Get All Handler
 */
const getAllsHandler = async (req: Request, res: Response, next: NextFunction): Promise<any> => {
  try {
    await tradingEconomicsNewController.getAll(req, res, next);
  } catch (error) {
    next(error);
  }
};

/**
 * Get By ID Handler
 */
const getByIdHandler = async (req: Request, res: Response, next: NextFunction) => {
  try {
    await tradingEconomicsNewController.getById(req, res, next);
  } catch (error) {
    next(error);
  }
}

/**
 * Update Handler
 */
const updateHandler = async (req: Request, res: Response, next: NextFunction) => {
  try {
    await tradingEconomicsNewController.update(req, res, next);
  } catch (error) {
    next(error);
  }
}

/**
 * Delete Handler
 */
const deleteHandler = async (req: Request, res: Response, next: NextFunction) => {
  try {
    await tradingEconomicsNewController.delete(req, res, next);
  } catch (error) {
    next(error);
  }
}

export {
  validateCreateDTO,
  validateIdDTO,
  validateUpdateDTO,
  createHandler,
  deleteHandler,
  getAllsHandler,
  getByIdHandler,
  updateHandler
};


================================================
File: src/modules/trading-economics-new/trading-economics-new.interface.ts
================================================
export interface ITradingEconomicsNew {
  id?: string;
  title: string;
  content: string;
  time: string;
  link: string;
  timestamp?: number;
}

export interface ProcessedDataPost {
  validItems: Array<ITradingEconomicsNew & { processedTimestamp: number }>;
  totalValidItems?: number;
  lastNewTime?: number;
  lastNewTitle?: string;
}


export interface UpdateProcess {
  lastNewTime?: number;
  lastNewTitle?: string;
}

================================================
File: src/modules/trading-economics-new/trading-economics-new.module.ts
================================================
import { Container } from 'typedi';
import TradingEconomicsNewController from './trading-economics-new.controller';
import TradingEconomicsNewService from './trading-economics-new.service';
import TradingEconomicsNewRepository from './trading-economics-new.repository';


class TradingEconomicsNewModule {
    public tradingEconomicsNewController: TradingEconomicsNewController;
    public tradingEconomicsNewService: TradingEconomicsNewService;
    public tradingEconomicsNewRepository: TradingEconomicsNewRepository;

    constructor() {
        this.tradingEconomicsNewController = Container.get(TradingEconomicsNewController);
        this.tradingEconomicsNewService = Container.get(TradingEconomicsNewService);
        this.tradingEconomicsNewRepository = Container.get(TradingEconomicsNewRepository);
    }
}

const tradingEconomicsNewModule = new TradingEconomicsNewModule();

export const { tradingEconomicsNewController, tradingEconomicsNewService, tradingEconomicsNewRepository } = tradingEconomicsNewModule;

================================================
File: src/modules/trading-economics-new/trading-economics-new.repository.ts
================================================
// trading-economics-new.repository.ts
import { Service } from 'typedi';
import { BaseRepository } from '../_base/crud/BaseRepository';
import { ITradingEconomicsNew } from './trading-economics-new.interface';

@Service()
export class TradingEconomicsNewRepository extends BaseRepository<ITradingEconomicsNew> {
  constructor() {
    super('trading-economics-news');
  }
}
export default TradingEconomicsNewRepository;


================================================
File: src/modules/trading-economics-new/trading-economics-new.service.ts
================================================
// trading-economics-new.service.ts
import TradingEconomicsNewRepository from './trading-economics-new.repository';
import { ITradingEconomicsNew } from './trading-economics-new.interface';
import { Service } from 'typedi';
import { BaseService } from '../_base/crud/BaseService';

@Service()
class TradingEconomicsNewService extends BaseService<ITradingEconomicsNew> {
  constructor(repository: TradingEconomicsNewRepository) {
    super(repository);
  }

  // ✅ You can add TradingEconomicsNew-specific methods here
  // async getTradingEconomicsNewsByStatus(status: string): Promise<ITradingEconomicsNew[]> {
  //   const allTradingEconomicsNews = await this.getAll();
  //   return allTradingEconomicsNews.filter((trading-economics-new) => trading-economics-new.status === status);
}

export default TradingEconomicsNewService;

================================================
File: src/modules/trading-economics-new/trading-economics-new.validation.ts
================================================
// trading-economics-news.validation.ts
import { z } from 'zod';

// ✅ Create Schema
export const CreateSchema = z.object({
  title: z.string().min(1, 'Title is required'),
  content: z.string().min(1, 'Content is required'),
  time: z.string().min(1, 'Time is required'),
  link: z.string().url('Link must be a valid URL'),
  timestamp: z.number().optional(),
});

// ✅ Update Schema
export const UpdateSchema = z.object({
  title: z.string().min(1, 'Title is required').optional(),
  content: z.string().min(1, 'Content is required').optional(),
  time: z.string().min(1, 'Time is required').optional(),
  link: z.string().url('Link must be a valid URL').optional(),
  timestamp: z.number().optional(),
});

// ✅ ID Schema
export const IdSchema = z.object({
  id: z.string().min(1, 'ID is required'),
});


================================================
File: src/scripts/bot/fetch-html-background.py
================================================
import schedule
import time
import logging
from datetime import datetime
import re
import os
import sys
import json
from bs4 import BeautifulSoup
from urllib.parse import urlparse
from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from webdriver_manager.chrome import ChromeDriverManager
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

from selenium.webdriver.chrome.options import Options


# Configure logging with timestamp
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(message)s',
    handlers=[
        logging.FileHandler("scraper.log"),
        logging.StreamHandler()
    ]
)

class BackgroundURLScraper:
    def __init__(self, url):
        print(f"\n{'='*50}")
        print(f"Initializing scraper for URL: {url}")
        print(f"{'='*50}\n")
        self.url = url
        self.MAX_DAY = 2
        self.MAX_HOUR = 48
        self.setup_driver()
        
    def setup_driver(self):
        """Configure headless browser"""
        try:
            print("\n[SETUP] Configuring Chrome options...")
            options = webdriver.ChromeOptions()
            options.add_argument("--headless=new")
            options.add_argument("--disable-gpu")
            options.add_argument("--enable-unsafe-swiftshader")
            options.add_argument("--no-sandbox")
            options.add_argument("--disable-dev-shm-usage")
            options.add_argument("--window-size=1920,1080")
            options.add_argument("--disable-search-engine-choice-screen")
            options.add_argument("--disable-blink-features=AutomationControlled")
            options.add_argument("--disable-extensions")
            options.add_argument("--disable-notifications")
            options.add_argument("--ignore-certificate-errors")
            options.add_argument("--ignore-ssl-errors")
            options.add_argument('--disable-javascript')  # Try without JavaScript first
            options.add_argument("user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36")
            
            print("[SETUP] Initializing Chrome driver...")
            self.driver = webdriver.Chrome(
                service=Service(ChromeDriverManager().install()),
                options=options
            )
            
            # Set page load timeout
            self.driver.set_page_load_timeout(30)
            
            print("[SETUP] ✓ Browser initialized successfully in headless mode")
        except Exception as e:
            print(f"[ERROR] Browser initialization failed: {str(e)}")
            raise

    def fetch_data(self):
        """Main fetch operation"""
        try:
            print(f"\n{'='*50}")
            print(f"Starting new fetch operation at {datetime.now()}")
            print(f"{'='*50}")
            
            print(f"\n[FETCH] Loading URL: {self.url}")
            self.driver.get(self.url)
            
            print("[FETCH] Scrolling page to load dynamic content...")
            self.scroll_to_bottom()
            
            print("[FETCH] Extracting content...")
            content = self.extract_list_content()
            
            if content:
                print("[FETCH] Converting content to JSON...")
                json_data = self.extract_data_as_json(content)
                
                if json_data:
                    print("[FETCH] Saving data to file...")
                    self.save_to_file(json_data)
                    print("[FETCH] ✓ Fetch operation completed successfully")
                else:
                    print("[ERROR] Failed to convert content to JSON")
            else:
                print("[ERROR] No content extracted")
                
        except Exception as e:
            print(f"[ERROR] Fetch operation failed: {e}")
            
            
            

    def scroll_to_bottom(self):
        """Scroll to load dynamic content"""
        scroll_count = 0
        last_height = self.driver.execute_script("return document.body.scrollHeight")
        
        while True:
            scroll_count += 1
            print(f"[SCROLL] Scroll attempt #{scroll_count}")
            
            self.driver.execute_script("window.scrollTo(0, document.body.scrollHeight);")
            time.sleep(3)
            
            new_height = self.driver.execute_script("return document.body.scrollHeight")
            if new_height == last_height:
                print("[SCROLL] ✓ Reached bottom of page")
                break
                
            print(f"[SCROLL] New content loaded (Height: {new_height}px)")
            last_height = new_height

    def extract_list_content(self):
        """Extract HTML content"""
        try:
            print("[EXTRACT] Analyzing page structure...")
            # First, let's print the page source to debug
            page_source = self.driver.page_source
            print("[EXTRACT] Page title:", self.driver.title)
            
            # Try different possible selectors
            possible_selectors = [
                ('//*[@id="stream"]', "Stream ID"),
                ('//*[@class="stream"]', "Stream Class"),
                ('//ul[contains(@class, "stream")]', "Stream UL"),
                ('//div[contains(@class, "stream")]', "Stream DIV")
            ]
            
            ul_element = None
            used_selector = None
            
            for selector, selector_name in possible_selectors:
                print(f"[EXTRACT] Trying selector: {selector_name}")
                try:
                    ul_element = WebDriverWait(self.driver, 5).until(
                        EC.presence_of_element_located((By.XPATH, selector))
                    )
                    if ul_element:
                        print(f"[EXTRACT] ✓ Found element using {selector_name}")
                        used_selector = selector_name
                        break
                except Exception as e:
                    print(f"[EXTRACT] {selector_name} not found, trying next...")
            
            if not ul_element:
                print("[EXTRACT] Attempting to find any list items on page...")
                try:
                    # Try to find any list items
                    list_items = self.driver.find_elements(By.TAG_NAME, 'li')
                    if list_items:
                        print(f"[EXTRACT] Found {len(list_items)} general list items")
                        ul_element = list_items[0].find_element(By.XPATH, '..')
                except Exception as e:
                    print("[EXTRACT] No list items found")
            
            if ul_element:
                print("[EXTRACT] Finding list items...")
                list_items = ul_element.find_elements(By.TAG_NAME, 'li')
                print(f"[EXTRACT] Found {len(list_items)} items")
                
                # Debug the first item if available
                if list_items:
                    print("[EXTRACT] First item HTML:")
                    print(list_items[0].get_attribute('outerHTML'))
                
                valid_data = []
                processed_count = 0

                for item in list_items:
                    try:
                        processed_count += 1
                        print(f"\n[PROCESS] Processing item {processed_count}/{len(list_items)}")
                        
                        # Try different time element selectors
                        time_selectors = [
                            ('small', 'Small tag'),
                            ('span[contains(@class, "time")]', 'Time span'),
                            ('div[contains(@class, "time")]', 'Time div'),
                            ('*[contains(text(), "ago")]', 'Text containing ago')
                        ]
                        
                        time_text = None
                        for selector, selector_name in time_selectors:
                            try:
                                time_element = item.find_element(By.CSS_SELECTOR, selector)
                                time_text = time_element.text.strip()
                                print(f"[PROCESS] Time found using {selector_name}: {time_text}")
                                break
                            except:
                                continue
                        
                        if not time_text:
                            print("[PROCESS] ⚠ No time element found, skipping age check")
                            valid_data.append(item.get_attribute('outerHTML'))
                            continue

                        hours_match = re.search(r'(\d+)\s+hours?\s+ago', time_text)
                        days_match = re.search(r'(\d+)\s+days?\s+ago', time_text)

                        if hours_match:
                            hours_ago = int(hours_match.group(1))
                            if hours_ago > self.MAX_HOUR:
                                print(f"[PROCESS] ⚠ Data too old ({hours_ago} hours), stopping")
                                break
                        elif days_match:
                            days_ago = int(days_match.group(1))
                            if days_ago >= self.MAX_DAY:
                                print(f"[PROCESS] ⚠ Data too old ({days_ago} days), stopping")
                                break

                        valid_data.append(item.get_attribute('outerHTML'))
                        print("[PROCESS] ✓ Item processed successfully")

                    except Exception as e:
                        print(f"[ERROR] Failed to process item: {str(e)}")
                        continue

                print(f"\n[EXTRACT] ✓ Successfully extracted {len(valid_data)} valid items")
                return '\n\n\n'.join(valid_data)
            else:
                print("[ERROR] No suitable container element found")
                return None

        except Exception as e:
            print(f"[ERROR] Content extraction failed: {str(e)}")
            # Print page source for debugging
            print("\n[DEBUG] Page source:")
            print(self.driver.page_source[:1000] + "...")  # Print first 1000 chars
            return None

    def extract_data_as_json(self, html_content):
        """Convert to JSON format"""
        try:
            print("[JSON] Parsing HTML content...")
            soup = BeautifulSoup(html_content, 'html.parser')
            
            print("[JSON] Finding stream items...")
            list_items = soup.find_all('li', class_='te-stream-item')
            print(f"[JSON] Found {len(list_items)} items to process")
            
            data_list = []
            
            for i, li in enumerate(list_items, 1):
                try:
                    print(f"[JSON] Processing item {i}/{len(list_items)}")
                    
                    title_element = li.select_one('div.te-stream-title-div a.te-stream-title, a.te-stream-title-2')
                    title = title_element.get_text(strip=True) if title_element else ''
                    link = title_element['href'] if title_element else ''
                    
                    time_element = li.find('small')
                    time_text = time_element.get_text(strip=True) if time_element else ''
                    
                    content = li.get_text(separator=' ').split(time_text)[0].strip() if time_text else li.get_text(separator=' ').strip()
                    
                    data_list.append({
                        "title": title,
                        "link": link,
                        "time": time_text,
                        "content": content
                    })
                    print(f"[JSON] ✓ Item {i} processed successfully")
                
                except Exception as e:
                    print(f"[ERROR] Failed to process JSON item {i}: {e}")
                    continue
            
            print(f"[JSON] ✓ Successfully converted {len(data_list)} items to JSON")
            return json.dumps(data_list, indent=4)

        except Exception as e:
            print(f"[ERROR] JSON conversion failed: {e}")
            return None

    def save_to_file(self, data):
        """Save data to file"""
        parsed_url = urlparse(self.url)
        domain = parsed_url.netloc.replace('.', '_')
        
        print(f"[SAVE] Preparing to save data for domain: {domain}")
        
        origin = "fetch-data"
        now = datetime.now()
        date_str = now.strftime("%Y-%m-%d")
        hour_str = now.strftime("%H")
        
        folder_path = os.path.join(origin, domain, date_str, hour_str)
        os.makedirs(folder_path, exist_ok=True)
        
        file_name = f"{domain}-{now.strftime('%Y-%m-%d-%H')}.txt"
        file_path = os.path.join(folder_path, file_name)
        
        print(f"[SAVE] Saving to: {file_path}")
        
        try:
            with open(file_path, 'w', encoding='utf-8') as file:
                file.write(data)
            print(f"[SAVE] ✓ Data successfully saved to {file_path}")
        except Exception as e:
            print(f"[ERROR] Failed to save file: {e}")

    def run_schedule(self):
        """Run scheduled scraping"""
        print("\n[SCHEDULE] Starting scheduled scraping...")
        
        schedule.every(1).hours.do(self.fetch_data)
        print("[SCHEDULE] Set to run every hour")
        
        print("[SCHEDULE] Running initial fetch...")
        self.fetch_data()
        
        try:
            while True:
                schedule.run_pending()
                time.sleep(60)
        except KeyboardInterrupt:
            print("\n[SCHEDULE] Stopping scraper...")
            self.cleanup()

    def cleanup(self):
        """Clean up resources"""
        try:
            if hasattr(self, 'driver'):
                self.driver.quit()
                print("[CLEANUP] ✓ Browser closed successfully")
        except Exception as e:
            print(f"[ERROR] Cleanup failed: {e}")

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: python scraper.py <url>")
        sys.exit(1)

    site_url = sys.argv[1]
    print(f"\nStarting scraper with URL: {site_url}")
    
    try:
        scraper = BackgroundURLScraper(site_url)
        scraper.run_schedule()
    except KeyboardInterrupt:
        print("\nScraper stopped by user")
    except Exception as e:
        print(f"Fatal error: {e}")

================================================
File: src/scripts/bot/fetch-html.py
================================================
import re
import os
import sys
import time
import json
from bs4 import BeautifulSoup

from urllib.parse import urlparse
from datetime import datetime
from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from webdriver_manager.chrome import ChromeDriverManager
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait  # Import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC  # Import Expected Conditions
from selenium.webdriver.common.action_chains import ActionChains
import logging
logging.basicConfig(level=logging.DEBUG)

MAX_DAY = 2
MAX_HOUR = 48

# Check if the URL is provided as a command-line argument
if len(sys.argv) < 2:
    print("Usage: python fetch-html.py <url>")
    sys.exit(1)

# Get the URL from the command-line argument
site_url = sys.argv[1]

def scroll_to_bottom(driver):
    """
    Scroll to the bottom of the page to load dynamic content.
    """
    last_height = driver.execute_script("return document.body.scrollHeight")
    
    while True:
        driver.execute_script("window.scrollTo(0, document.body.scrollHeight);")
        time.sleep(3)
        new_height = driver.execute_script("return document.body.scrollHeight")
        if new_height == last_height:
            break
        last_height = new_height

def fetch_html_with_selenium(site_url):
    """
    Fetch the HTML content using Selenium for JavaScript-rendered content.
    """
    options = webdriver.ChromeOptions()
    
    # Add the argument to disable the search engine choice popup
    options.add_argument("--disable-search-engine-choice-screen")

    driver = webdriver.Chrome(service=Service(ChromeDriverManager().install()), options=options)

    # Load the website
    driver.get(site_url)

    # Scroll to the bottom to ensure all content is loaded
    scroll_to_bottom(driver)

    # Wait for the specific element that signals the content is loaded
    WebDriverWait(driver, 10).until(
        EC.presence_of_element_located((By.ID, "stream"))  # Adjust as per the page structure
    )

    return driver





def extract_list_content_html_selenium(driver):
    """
    Extract HTML content from the specific element using Selenium and stop fetching if data is older than 40 hours or 2 days.
    """
    try:
        # Wait until the element with the specified XPath is present (up to 10 seconds)
        ul_element = WebDriverWait(driver, 10).until(
            EC.presence_of_element_located((By.XPATH, '//*[@id="stream"]'))
        )
        
        # Extract the list of <li> elements
        list_items = ul_element.find_elements(By.TAG_NAME, 'li')

        valid_data = []

        for item in list_items:
            try:
                # Find the <small> tag that contains the time information
                time_element = item.find_element(By.TAG_NAME, 'small')
                time_text = time_element.text.strip()

                # Match hours or days from the <small> tag text
                hours_match = re.search(r'(\d+)\s+hours?\s+ago', time_text)
                days_match = re.search(r'(\d+)\s+days?\s+ago', time_text)

                # Filter out data older than 40 hours or 2 days
                if hours_match:
                    hours_ago = int(hours_match.group(1))
                    if hours_ago > MAX_HOUR:
                        print(f"Data is older than 40 hours ({hours_ago} hours ago), stopping fetch.")
                        break
                elif days_match:
                    days_ago = int(days_match.group(1))
                    if days_ago >= MAX_DAY:
                        print(f"Data is older than 2 days ({days_ago} days ago), stopping fetch.")
                        break

                # If the data is valid, append the entire HTML content of the list item
                valid_data.append(item.get_attribute('outerHTML'))

            except Exception as e:
                print(f"Error processing item: {e}")
                continue

        return '\n\n\n'.join(valid_data)

    except Exception as e:
        print(f"Could not find the element: {e}")
        return None

    


def extract_data_as_json(html_content):
    """
    Extract the data from the HTML content using BeautifulSoup and return it as a list of dictionaries to be exported as JSON.
    """
    try:
        # Parse the HTML content using BeautifulSoup
        soup = BeautifulSoup(html_content, 'html.parser')
        
        # Find all the <li> elements within the parsed HTML
        list_items = soup.find_all('li', class_='te-stream-item')
        
        data_list = []
        
        for li in list_items:
            try:
                # Extract the title
                title_element = li.select_one('div.te-stream-title-div a.te-stream-title, a.te-stream-title-2')
                title = title_element.get_text(strip=True) if title_element else ''
                
                # Extract the link
                link = title_element['href'] if title_element else ''
                
                # Extract the time (like "13 hours ago" or "2 days ago")
                time_element = li.find('small')
                time_text = time_element.get_text(strip=True) if time_element else ''
                
                # Extract the content, excluding the time
                content = li.get_text(separator=' ').split(time_text)[0].strip() if time_text else li.get_text(separator=' ').strip()
                
                # Add the structured data to the list
                data_list.append({
                    "title": title,
                    "link": link,
                    "time": time_text,
                    "content": content
                })
            
            except Exception as e:
                print(f"Error processing list item: {e}")
                continue
        
        # Return the data as a JSON string
        return json.dumps(data_list, indent=4)

    except Exception as e:
        print(f"Could not process the HTML content: {e}")
        return None
    

def export_to_file(data, site_url, file_name):
    """
    Export the extracted data to a file, saving it in a folder structure.
    """
    # Parse the site URL to use as part of the folder structure
    parsed_url = urlparse(site_url)
    domain = parsed_url.netloc.replace('.', '_')  # Replace dots with underscores for folder name

    # Get the current date and time
    origin = "fetch-data"
    now = datetime.now()
    date_str = now.strftime("%Y-%m-%d")
    hour_str = now.strftime("%H")

    # Create the folder structure: [domain]/[date]/[hour]
    folder_path = os.path.join(origin, domain, date_str, hour_str)
    os.makedirs(folder_path, exist_ok=True)  # Create directories if they don't exist

    # Define the file path
    file_path = os.path.join(folder_path, file_name)

    try:
        with open(file_path, 'w', encoding='utf-8') as file:
            file.write(data)
        print(f"Data exported successfully to {file_path}")
    except IOError as e:
        print(f"Error writing to file {file_path}: {e}")

if __name__ == "__main__":
    driver = fetch_html_with_selenium(site_url)

    # Extract content from the specific list element
    list_content = extract_data_as_json(extract_list_content_html_selenium(driver))
    
    if list_content:
        # Save the extracted content to a file
        now = datetime.now()
        date_hour_str = now.strftime("%Y-%m-%d-%H")
        text_file_name = f"{urlparse(site_url).netloc.replace('.', '_')}-{date_hour_str}.txt"
        export_to_file(list_content, site_url, text_file_name)

    # Close the browser
    driver.quit()


================================================
File: src/scripts/bot/fetch-single-url-html-background.py
================================================
import schedule
import time
import logging
from datetime import datetime
import re
import os
import sys
import json
import random

from bs4 import BeautifulSoup
from urllib.parse import urlparse
from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from webdriver_manager.chrome import ChromeDriverManager
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

from selenium.webdriver.chrome.options import Options


# Configure logging with timestamp
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(message)s',
    handlers=[
        logging.FileHandler("scraper.log"),
        logging.StreamHandler()
    ]
)

class BackgroundURLScraper:
    def __init__(self, url):
        print(f"\n{'='*50}")
        print(f"Initializing scraper for URL: {url}")
        print(f"{'='*50}\n")
        self.url = url
        self.MAX_DAY = 2
        self.MAX_HOUR = 48
        self.setup_driver()
        
    def setup_driver(self):
        """Configure headless browser with stealth settings"""
        try:
            print("\n[SETUP] Configuring Chrome options...")
            options = webdriver.ChromeOptions()
            
            # Stealth settings
            options.add_argument('--disable-blink-features=AutomationControlled')
            options.add_experimental_option("excludeSwitches", ["enable-automation"])
            options.add_experimental_option('useAutomationExtension', False)
            
            # Regular settings
            options.add_argument("--headless=new")
            options.add_argument("--disable-gpu")
            options.add_argument("--enable-unsafe-swiftshader")
            options.add_argument("--no-sandbox")
            options.add_argument("--disable-dev-shm-usage")
            options.add_argument("--window-size=1920,1080")
            
            # Additional stealth settings
            options.add_argument(f'--user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36')
            options.add_argument('--disable-extensions')
            options.add_argument('--disable-infobars')
            options.add_argument('--lang=en-US,en')
            options.add_argument('--disable-dev-shm-usage')
            options.add_argument('--profile-directory=Default')
            options.add_argument('--remote-debugging-port=9222')
            
            print("[SETUP] Initializing Chrome driver...")
            service = Service(ChromeDriverManager().install())
            self.driver = webdriver.Chrome(service=service, options=options)
            
            # Additional stealth script
            self.driver.execute_cdp_cmd('Network.setUserAgentOverride', {
                "userAgent": 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36'
            })
            
            # Remove webdriver flag
            self.driver.execute_script("Object.defineProperty(navigator, 'webdriver', {get: () => undefined})")
            
            print("[SETUP] [SUCCESS] Browser initialized successfully in stealth mode")
        except Exception as e:
            print(f"[ERROR] Browser initialization failed: {str(e)}")
            raise

    def fetch_data(self):
        """Main fetch operation with additional stealth measures"""
        try:
            print(f"\n{'='*50}")
            print(f"Starting fetch operation at {datetime.now()}")
            print(f"{'='*50}")
            
            print(f"\n[FETCH] Loading URL: {self.url}")
            self.driver.get(self.url)
            
            # Add random delay to mimic human behavior
            time.sleep(random.uniform(2, 4))
            
            # Check for verification page
            if "Human Verification" in self.driver.title:
                print("[FETCH] Detected verification page, attempting bypass...")
                try:
                    # Wait for page to fully load
                    time.sleep(3)
                    # You might need to add specific handling for the verification page here
                    print("[FETCH] Attempting to navigate verification...")
                except Exception as e:
                    print(f"[ERROR] Failed to bypass verification: {e}")
                    return False
            
            print("[FETCH] Scrolling page to load dynamic content...")
            self.scroll_to_bottom()
            
            print("[FETCH] Extracting content...")
            content = self.extract_list_content()
            
            if content:
                print("[FETCH] Converting content to JSON...")
                json_data = self.extract_data_as_json(content)
                
                if json_data:
                    print("[FETCH] Saving data to file...")
                    self.save_to_file(json_data)
                    print("[FETCH] [SUCCESS] Fetch operation completed successfully")
                    return True
                else:
                    print("[ERROR] Failed to convert content to JSON")
            else:
                print("[ERROR] No content extracted")
                
            return False
                
        except Exception as e:
            print(f"[ERROR] Fetch operation failed: {e}")
            return False
            

    def scroll_to_bottom(self):
        """Scroll with human-like behavior"""
        try:
            scroll_count = 0
            last_height = self.driver.execute_script("return document.body.scrollHeight")
            
            while True:
                scroll_count += 1
                print(f"[SCROLL] Scroll attempt #{scroll_count}")
                
                # Random scroll amount
                scroll_amount = random.uniform(0.7, 1.0)
                self.driver.execute_script(f"window.scrollTo(0, document.body.scrollHeight * {scroll_amount});")
                
                # Random delay between scrolls
                time.sleep(random.uniform(1, 3))
                
                new_height = self.driver.execute_script("return document.body.scrollHeight")
                if new_height == last_height:
                    print("[SCROLL] [SUCCESS] Reached bottom of page")
                    break
                    
                print(f"[SCROLL] New content loaded (Height: {new_height}px)")
                last_height = new_height
                
                # Add random pause between scrolls
                time.sleep(random.uniform(0.5, 1.5))
        except Exception as e:
            print(f"[ERROR] Scroll operation failed: {e}")

    def extract_list_content(self):
        """Extract HTML content"""
        try:
            print("[EXTRACT] Analyzing page structure...")
            # First, let's print the page source to debug
            page_source = self.driver.page_source
            print("[EXTRACT] Page title:", self.driver.title)
            
            # Try different possible selectors
            possible_selectors = [
                ('//*[@id="stream"]', "Stream ID"),
                ('//*[@class="stream"]', "Stream Class"),
                ('//ul[contains(@class, "stream")]', "Stream UL"),
                ('//div[contains(@class, "stream")]', "Stream DIV")
            ]
            
            ul_element = None
            used_selector = None
            
            for selector, selector_name in possible_selectors:
                print(f"[EXTRACT] Trying selector: {selector_name}")
                try:
                    ul_element = WebDriverWait(self.driver, 5).until(
                        EC.presence_of_element_located((By.XPATH, selector))
                    )
                    if ul_element:
                        print(f"[EXTRACT] [SUCCESS] Found element using {selector_name}")
                        used_selector = selector_name
                        break
                except Exception as e:
                    print(f"[EXTRACT] {selector_name} not found, trying next...")
            
            if not ul_element:
                print("[EXTRACT] Attempting to find any list items on page...")
                try:
                    # Try to find any list items
                    list_items = self.driver.find_elements(By.TAG_NAME, 'li')
                    if list_items:
                        print(f"[EXTRACT] Found {len(list_items)} general list items")
                        ul_element = list_items[0].find_element(By.XPATH, '..')
                except Exception as e:
                    print("[EXTRACT] No list items found")
            
            if ul_element:
                print("[EXTRACT] Finding list items...")
                list_items = ul_element.find_elements(By.TAG_NAME, 'li')
                print(f"[EXTRACT] Found {len(list_items)} items")
                
                # Debug the first item if available
                if list_items:
                    print("[EXTRACT] First item HTML:")
                    print(list_items[0].get_attribute('outerHTML'))
                
                valid_data = []
                processed_count = 0

                for item in list_items:
                    try:
                        processed_count += 1
                        print(f"\n[PROCESS] Processing item {processed_count}/{len(list_items)}")
                        
                        # Try different time element selectors
                        time_selectors = [
                            ('small', 'Small tag'),
                            ('span[contains(@class, "time")]', 'Time span'),
                            ('div[contains(@class, "time")]', 'Time div'),
                            ('*[contains(text(), "ago")]', 'Text containing ago')
                        ]
                        
                        time_text = None
                        for selector, selector_name in time_selectors:
                            try:
                                time_element = item.find_element(By.CSS_SELECTOR, selector)
                                time_text = time_element.text.strip()
                                print(f"[PROCESS] Time found using {selector_name}: {time_text}")
                                break
                            except:
                                continue
                        
                        if not time_text:
                            print("[PROCESS] ⚠ No time element found, skipping age check")
                            valid_data.append(item.get_attribute('outerHTML'))
                            continue

                        hours_match = re.search(r'(\d+)\s+hours?\s+ago', time_text)
                        days_match = re.search(r'(\d+)\s+days?\s+ago', time_text)

                        if hours_match:
                            hours_ago = int(hours_match.group(1))
                            if hours_ago > self.MAX_HOUR:
                                print(f"[PROCESS] ⚠ Data too old ({hours_ago} hours), stopping")
                                break
                        elif days_match:
                            days_ago = int(days_match.group(1))
                            if days_ago >= self.MAX_DAY:
                                print(f"[PROCESS] ⚠ Data too old ({days_ago} days), stopping")
                                break

                        valid_data.append(item.get_attribute('outerHTML'))
                        print("[PROCESS] [SUCCESS] Item processed successfully")

                    except Exception as e:
                        print(f"[ERROR] Failed to process item: {str(e)}")
                        continue

                print(f"\n[EXTRACT] [SUCCESS] Successfully extracted {len(valid_data)} valid items")
                return '\n\n\n'.join(valid_data)
            else:
                print("[ERROR] No suitable container element found")
                return None

        except Exception as e:
            print(f"[ERROR] Content extraction failed: {str(e)}")
            # Print page source for debugging
            print("\n[DEBUG] Page source:")
            print(self.driver.page_source[:1000] + "...")  # Print first 1000 chars
            return None

    def extract_data_as_json(self, html_content):
        """Convert to JSON format"""
        try:
            print("[JSON] Parsing HTML content...")
            soup = BeautifulSoup(html_content, 'html.parser')
            
            print("[JSON] Finding stream items...")
            list_items = soup.find_all('li', class_='te-stream-item')
            print(f"[JSON] Found {len(list_items)} items to process")
            
            data_list = []
            
            for i, li in enumerate(list_items, 1):
                try:
                    print(f"[JSON] Processing item {i}/{len(list_items)}")
                    
                    title_element = li.select_one('div.te-stream-title-div a.te-stream-title, a.te-stream-title-2')
                    title = title_element.get_text(strip=True) if title_element else ''
                    link = title_element['href'] if title_element else ''
                    
                    time_element = li.find('small')
                    time_text = time_element.get_text(strip=True) if time_element else ''
                    
                    content = li.get_text(separator=' ').split(time_text)[0].strip() if time_text else li.get_text(separator=' ').strip()
                    
                    data_list.append({
                        "title": title,
                        "link": link,
                        "time": time_text,
                        "content": content
                    })
                    print(f"[JSON] [SUCCESS] Item {i} processed successfully")
                
                except Exception as e:
                    print(f"[ERROR] Failed to process JSON item {i}: {e}")
                    continue
            
            print(f"[JSON] [SUCCESS] Successfully converted {len(data_list)} items to JSON")
            return json.dumps(data_list, indent=4)

        except Exception as e:
            print(f"[ERROR] JSON conversion failed: {e}")
            return None

    def save_to_file(self, data):
        """Save data to file"""
        parsed_url = urlparse(self.url)
        domain = parsed_url.netloc.replace('.', '_')
        
        print(f"[SAVE] Preparing to save data for domain: {domain}")
        
        origin = "fetch-data"
        now = datetime.now()
        date_str = now.strftime("%Y-%m-%d")
        hour_str = now.strftime("%H")
        
        folder_path = os.path.join(origin, domain, date_str, hour_str)
        os.makedirs(folder_path, exist_ok=True)
        
        file_name = f"{domain}-{now.strftime('%Y-%m-%d-%H')}.txt"
        file_path = os.path.join(folder_path, file_name)
        
        print(f"[SAVE] Saving to: {file_path}")
        
        try:
            with open(file_path, 'w', encoding='utf-8') as file:
                file.write(data)
            print(f"[SAVE] [SUCCESS] Data successfully saved to {file_path}")
        except Exception as e:
            print(f"[ERROR] Failed to save file: {e}")

    def run_once(self):
        """Run single scraping operation"""
        print("\n[EXECUTE] Starting single scraping operation...")
        try:
            success = self.fetch_data()
            self.cleanup()  # Always cleanup
            return success
        except Exception as e:
            print(f"[ERROR] Scraping operation failed: {e}")
            self.cleanup()  # Always cleanup
            return False
    

    def cleanup(self):
        """Clean up resources"""
        try:
            if hasattr(self, 'driver'):
                self.driver.quit()
                print("[CLEANUP] [SUCCESS] Browser closed successfully")
        except Exception as e:
            print(f"[ERROR] Cleanup failed: {e}")

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: python scraper.py <url>")
        sys.exit(1)

    site_url = sys.argv[1]
    print(f"\nStarting scraper with URL: {site_url}")
    
    try:
        scraper = BackgroundURLScraper(site_url)
        success = scraper.run_once()  # Run once instead of scheduling
        
        if success:
            print("\n[SUCCESS] Scraping completed successfully")
            sys.exit(0)  # Exit with success code
        else:
            print("\n[FAILURE] Scraping failed")
            sys.exit(1)  # Exit with error code
            
    except KeyboardInterrupt:
        print("\nScraper stopped by user")
        sys.exit(1)
    except Exception as e:
        print(f"Fatal error: {e}")
        sys.exit(1)


================================================
File: src/scripts/bot/test.py
================================================
# Create a test.py file with this content
import win32serviceutil
print("Successfully imported win32serviceutil")

================================================
File: src/scripts/openai/analyze_news.py
================================================
import sys
import json
from ask0 import process_news_by_id  # Import your existing functions

def main():
    if len(sys.argv) < 2:
        json.dump({
            "status": "error",
            "message": "News ID is required"
        }, sys.__stdout__)
        return

    news_id = sys.argv[1]
    result = process_news_by_id(news_id)
    
    # Print only the JSON result to stdout
    json.dump(result, sys.__stdout__)

if __name__ == "__main__":
    main()

================================================
File: src/scripts/openai/ask0.py
================================================
import sys
import json
from datetime import datetime
import firebase_admin
from firebase_admin import credentials, db
from openai import OpenAI
import os
import re
from dotenv import load_dotenv
import pathlib
from deep_translator import GoogleTranslator
import spacy #library for NER, which is well-suited for extracting geographical entities.

# Suppress print statements or redirect them to stderr for debugging
import sys
import logging

nlp = spacy.load("en_core_web_sm")
# List of all countries (you can extend this list)
COUNTRIES = {
    "vietnam", "brazil", "usa", "united states", "china", "japan", "germany",
    "france", "india", "russia", "canada", "australia", "uk", "united kingdom",
    "south korea", "italy", "mexico", "indonesia", "saudi arabia", "south africa",
    "argentina", "turkey", "spain", "netherlands", "switzerland"
}


def detect_country(content):
    """
    Detect the relevant country from the content.
    Returns the detected country or 'global' if no country is identified.
    """
    # Run NER to identify geopolitical entities
    doc = nlp(content)
    
    detected_countries = set()
    
    # Extract geopolitical entities (GPE)
    for ent in doc.ents:
        if ent.label_ == "GPE" and ent.text.lower() in COUNTRIES:
            detected_countries.add(ent.text.lower())
    
    if detected_countries:
        # If multiple countries are detected, return the first one (or customize as needed)
        return list(detected_countries)[0]
    
    # Fallback to 'global' if no country is identified
    return "global"

class Logger:
    def __init__(self, filename="debug.log"):
        self.terminal = sys.stderr
        self.log = open(filename, "a")

    def write(self, message):
        self.terminal.write(message)
        self.log.write(message)

    def flush(self):
        pass

sys.stdout = Logger()

# Your existing initialization code
load_dotenv()
current_dir = pathlib.Path(__file__).parent.absolute()
key_path = os.path.join(current_dir, "config", "aianalist-firebase-adminsdk-8gwkb-09a794ac72.json")

# Initialize Firebase
if not firebase_admin._apps:
    cred = credentials.Certificate(key_path)
    firebase_admin.initialize_app(cred, {
        'databaseURL': os.getenv('FIREBASE_DATABASE_URL')
    })

client = OpenAI(api_key=os.getenv('OPENAI_API_KEY'))
if not os.getenv('OPENAI_API_KEY'):
    raise ValueError("OpenAI API Key not found in .env file.")

def translate_to_vietnamese(text):
    """Translate English text to Vietnamese"""
    try:
        translator = GoogleTranslator(source='en', target='vi')
        return translator.translate(text)
    except Exception as e:
        print(f"Translation error: {e}")
        return text

def get_latest_data_from_firebase():
    ref = db.reference('news')
    data = ref.order_by_child('timestamp').limit_to_last(1).get()
    if data:
        for key, value in data.items():
            return key, value
    return None, None

def simple_market_analysis(content):
    """Fallback analysis for Vietnam's market impact when OpenAI API fails."""
    # Define positive and negative keywords for Vietnam's market
    positive_words = [
        'growth', 'expansion', 'surge', 'increase', 'boost', 'record high', 'recovery', 'resilient', 'strong'
    ]
    negative_words = [
        'decline', 'drop', 'losses', 'downturn', 'uncertainty', 'inflation', 'depreciation', 'concerns', 'weak'
    ]
    
    # Define Vietnam-specific sectors and messages
    keywords_actions = [
        {
            "keywords": ["vn-index", "ho chi minh stock exchange", "hnx", "upcom"],
            "message": "Movements in Vietnam's stock market indices reflect investor sentiment and overall economic conditions."
        },
        {
            "keywords": ["manufacturing", "exports", "supply chain", "industrial output"],
            "message": "The manufacturing sector is a key driver of Vietnam's economic performance and reflects global trade trends."
        },
        {
            "keywords": ["agriculture", "rice exports", "coffee exports", "fisheries"],
            "message": "Agricultural exports, including rice and coffee, play a crucial role in Vietnam's trade balance."
        },
        {
            "keywords": ["foreign investment", "fdi", "inward investment", "foreign capital"],
            "message": "Foreign direct investment strengthens Vietnam's industrial base and economic growth."
        },
        {
            "keywords": ["tourism", "hospitality", "travel sector", "tourist arrivals"],
            "message": "Growth in tourism supports Vietnam's service sector and benefits local businesses."
        },
        {
            "keywords": ["vietnamese dong", "vnd", "currency exchange", "forex", "exchange rate"],
            "message": "Fluctuations in the Vietnamese Dong impact trade dynamics and investor confidence."
        },
        {
            "keywords": ["renewable energy", "solar", "wind", "hydropower"],
            "message": "Vietnam's push for renewable energy projects aligns with sustainability and energy independence goals."
        },
        {
            "keywords": ["cptpp", "rcep", "trade agreement", "fta"],
            "message": "Participation in trade agreements like CPTPP and RCEP boosts Vietnam's export opportunities."
        },
        {
            "keywords": ["inflation", "interest rates", "monetary policy"],
            "message": "Changes in inflation and interest rates affect consumer spending and investment in Vietnam."
        },
        {
            "keywords": ["real estate", "property market", "housing"],
            "message": "Vietnam's growing property market indicates robust urban development and domestic demand."
        }
    ]
    
    content_lower = content.lower()
    positive_count = sum(content_lower.count(word) for word in positive_words)
    negative_count = sum(content_lower.count(word) for word in negative_words)
    
    sentiment = "neutral"
    if positive_count > negative_count:
        sentiment = "potentially positive"
    elif negative_count > positive_count:
        sentiment = "potentially negative"
    
    analysis = [f"Market sentiment appears {sentiment} for Vietnam's economy."]
    
    for entry in keywords_actions:
        matched_keywords = [kw for kw in entry["keywords"] if kw in content_lower]
        if matched_keywords:
            logging.info(f"Matched keywords: {matched_keywords}")
            analysis.append(entry["message"])
    
    vietnamese_analysis = translate_to_vietnamese(" ".join(analysis))
    return {
        "english": " ".join(analysis),
        "vietnamese": vietnamese_analysis
    }

def process_news_by_id(news_id):
    try:
        ref = db.reference(f'news/{news_id}')
        news_data = ref.get()
        
        if not news_data:
            return {
                "status": "error",
                "message": f"News with ID {news_id} not found"
            }
            
        if news_data.get('analysis') and news_data['analysis'].get('status') == 'completed':
            return {
                "status": "skip",
                "message": "Analysis already exists",
                "data": news_data['analysis']
            }
            
        content = news_data.get('content')
        if not content:
            return {
                "status": "error",
                "message": "News content not found"
            }
            
        analysis = ask_chatgpt(content)
        
        if analysis:
            update_data = {
                'analysis': {
                    'en': analysis["english"],
                    'vi': analysis["vietnamese"],
                    'timestamp': datetime.now().timestamp(),
                    'status': 'completed'
                }
            }
            ref.update(update_data)
            
            return {
                "status": "success",
                "message": "Analysis completed and saved",
                "data": update_data['analysis']
            }
        else:
            return {
                "status": "error",
                "message": "Failed to generate analysis"
            }
            
    except Exception as e:
        return {
            "status": "error",
            "message": f"Error processing news: {str(e)}"
        }
        
def ask_chatgpt(content):
    
    """Use OpenAI API to analyze the impact on the Vietnamese market."""
    prompt = f"""
    Analyze the following news and determine its impact on Vietnam's economy or not. Provide a detailed analysis.\n\nNews: {content}
    """
    try:
        # First try OpenAI
        response = client.chat.completions.create(
            model="gpt-3.5-turbo",
            messages=[
                {"role": "system", "content": "You are an expert economic analyst who evaluates news impact on Vietnam's economy."},
                {"role": "user", "content": prompt}
            ],
            max_tokens=500,
            temperature=0.4
        )
        english_analysis = response.choices[0].message.content.strip()
        vietnamese_analysis = translate_to_vietnamese(english_analysis)
        
        logging.info("OpenAI API call successful.")
        return {
            "english": english_analysis,
            "vietnamese": vietnamese_analysis
        }
    except Exception as e:
        logging.error(f"OpenAI API error: {e}")
        logging.info("Falling back to simple analysis...")
        # Fallback to simple analysis
        return simple_market_analysis(content)

def main():
    from datetime import datetime
    
    key, data = get_latest_data_from_firebase()
    if data:
        content = data.get('content')
        print(f"Data from Firebase (ID: {key}):")
        print(content)
        print("\n" + "="*50 + "\n")
        
        # Get analysis in both languages
        analysis = ask_chatgpt(content)
        
        if analysis:
            print("English Analysis:")
            print(analysis["english"])
            print("\n" + "="*50 + "\n")
            print("Vietnamese Analysis:")
            print(analysis["vietnamese"])
            
            try:
                # Save both analyses back to Firebase
                ref = db.reference(f'news/{key}')
                update_data = {
                    'analysis': {
                        'en': analysis["english"],
                        'vi': analysis["vietnamese"],
                        'timestamp': datetime.now().timestamp(),
                        'status': 'completed'
                    }
                }
                
                ref.update(update_data)
                print(f"\n✓ Analysis saved to Firebase successfully for item ID: {key}")
                
                # Verify the save
                saved_data = db.reference(f'news/{key}/analysis').get()
                if saved_data:
                    print("\nSaved data verification:")
                    print(f"English saved: {len(saved_data.get('en', ''))} characters")
                    print(f"Vietnamese saved: {len(saved_data.get('vi', ''))} characters")
                
            except Exception as e:
                print(f"\n [Error] saving to Firebase: {e}")
        else:
            print("Failed to get analysis from ChatGPT.")
    else:
        print("No data found in Firebase.")

if __name__ == "__main__":
    main()

================================================
File: src/scripts/openai/config/aianalist-firebase-adminsdk-8gwkb-09a794ac72.json
================================================
{
    "type": "service_account",
    "project_id": "aianalist",
    "private_key_id": "09a794ac72679c5b58126cc8eb9edfeafd639124",
    "private_key": "-----BEGIN PRIVATE KEY-----\nMIIEvAIBADANBgkqhkiG9w0BAQEFAASCBKYwggSiAgEAAoIBAQCGhC8rCh3eHjkD\n3FTtfqD6+YgrI++wZ0AtVzNEXgiJCyyVoA3haGq1si7MKDVczMWdcb2jnOKDYnM4\nhI2//XBRpsRUneMSSISueRu1zEWIHudWSLCuggoSPEmSTTeNpnFR+yS918SBI1Mc\nWr9214W68ogttbPr1PSxvheEkCrtSinadvapAJDCVa5DP6z1Wk7gmjv3q2jfwo9y\n5UJqXM0iBXhoGLIPR8x4JjWCo0PIrGzoHVBSqnXA4t4UPW0gW89ho8rogcQTocWH\nmhxA2dni4Xh0Mfjse8DHpjRy6YbXkf9AnI+wRIS5NuFh+PB8F22pNIG6g3Z20fIp\nvAbi9RtRAgMBAAECggEAALtX8y7I3ZAyHMt5B089bTbIZxKuRMTfsvdy2xP8uCZ6\n9D1Et2WX51vm2Fu+JD56yJSJih9fVe9mI32Iyg2lC9QBpK5fYZZf1BVVgXemZ7CN\nBI7x7iBykVQ/DWLqktSABeiyaRl9yKWSbSNbFWM5XNG3DFzyaQMANKDX/tPBdgfD\nnbVUteKERj4snf2p1F217eHyXmkMLO9GYrrvRSv1kIDnP74iyopo74PgALtkVW5O\nW8OnedYlOXCGyKq0yT1QD/o9McBICMJJI48JUCDsh6d3tCRJMFSoHu25Igms4l4q\nGaYu6zsdHWGgErzLtEC0NS2ItNcBC2w/U2v4XtKGwQKBgQC5wGiTadnbzVDIeeew\nvWB8vkp5zW9Ox7jU19/gDpruGNF0Nrxfbba30qWYxQmUGPaPoh0j9lkMvPhmqJNZ\nP0JM8QbUz1d5lm5mSPDizdFgn2ZJUlV3WryfQvvUwzPcvCTzu05OX7d96xkyxFvA\nz78ciDO4IAEDGXenjd+m07EhYQKBgQC5Y2vB1sl9ojc6kosuujSqP1w7nG2kiGHQ\nYaZHFmT9IRmgtB7wSWgNMO6asHPamE3+fZt6x6INf3j6+fyfZDcAF6msHt3q2GW8\nZf7ovAKV/NlQvYbyCJF7gdh91bjkQ8dq2bzHlYQh4jKJd67/thqoCHJ3LtYufQEz\nD/c14EAP8QKBgBqbwV88joS6CJRvQg1DU4sLB0gjcYprecKjmeJStUbeL0LihGF3\nKfFzL12O/CxG1ysEIgCAzYjRmRO7mj/ym+DBtiTN/s3gCriEQl169j9NFi3yqWOL\nj/GQetqji85W9UQk1LbNZ0+WWem3zxzzpYDE0gPSMdLr1wQdgqg3MuyBAoGAclxu\nYMkKysGCqFM2IMElM9CaKPu6d0Dadh2G4VtjOPNuR8BVRY1C7sA8sJghH7vMgS0i\n+H6l7QWxr8D+oaTEeP4f4Nm5s+GCANI6iX9RaQztUe1YjX3ToQjcb+Ojhsx4++UN\nm2EUfYJ4Am0eOwgvMXDki7kMzui2ELXMniOT4UECgYBKtS8kWfQbVZyVlBBtLA1X\nXn5NsuqRAhHtEg6MW7U1dALq/4OzbpQy1gW7iGCvCb8va82lyNW3VQShxszBVnYc\n/e/IQiKcQK1S1ilPj9NjuIyUdpnXT7A9OLCM+OHBwKmh4FrFxtYiykTuidCf+vWE\n21OSsV1gWMvoHI1VRvTM2w==\n-----END PRIVATE KEY-----\n",
    "client_email": "firebase-adminsdk-8gwkb@aianalist.iam.gserviceaccount.com",
    "client_id": "111812980627088023465",
    "auth_uri": "https://accounts.google.com/o/oauth2/auth",
    "token_uri": "https://oauth2.googleapis.com/token",
    "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
    "client_x509_cert_url": "https://www.googleapis.com/robot/v1/metadata/x509/firebase-adminsdk-8gwkb%40aianalist.iam.gserviceaccount.com",
    "universe_domain": "googleapis.com"
  }
  

================================================
File: src/scripts/test-path-converter.ts
================================================
// scripts/test-path-converter.ts
import { spawnSync } from 'child_process';

const testPath = process.argv[2];
if (!testPath) {
    console.error('Please provide a test file path');
    process.exit(1);
}

const fixedPath = testPath.replace(/\\/g, '/');
spawnSync('npx', ['jest', fixedPath], { 
    stdio: 'inherit',
    shell: true 
});

================================================
File: src/utils/clean-doublon.ts
================================================
import { ref, get, child, remove } from "firebase/database";
import { database } from '@/_core/database/firebase-admin-sdk';  // Import Firebase config

/**
 * Clean duplicate data from the 'news' node in Firebase based on the `title` field.
 */
export async function cleanFirebaseData() {
    try {
        const newsRef = ref(database, 'news/');
        const snapshot = await get(newsRef);

        if (!snapshot.exists()) {
            console.log("No data available in 'news/' node.");
            return;
        }

        // Retrieve all data as an object
        const data = snapshot.val();
        const uniqueTitles = new Set<string>();
        const updates: Record<string, { title: string }> = {}; // To track updates for retaining unique entries
        const deletions: string[] = []; // To track duplicates for deletion

        for (const [key, item] of Object.entries(data as Record<string, { title: string }>)) {
            if (!uniqueTitles.has(item.title)) {
                uniqueTitles.add(item.title); // Keep unique titles
                updates[key] = item; // Retain the unique entry
            } else {
                deletions.push(key); // Mark duplicate for deletion
            }
        }

        console.log("Duplicate entries found:", deletions.length);

        // Remove duplicate entries from Firebase
        for (const key of deletions) {
            await remove(child(newsRef, key));
            console.log(`Deleted duplicate with key: ${key}`);
        }

        console.log("Firebase data cleaned successfully!");

    } catch (error) {
        console.error("Error cleaning Firebase data:", error);
    }
}


================================================
File: src/utils/firebase-utils.service.ts
================================================
import { getAuth, signInWithCustomToken, signInWithEmailAndPassword, createUserWithEmailAndPassword } from 'firebase/auth';
import { getFirestore, doc, setDoc, getDoc, collection, query, where, getDocs, orderBy, limit, startAfter, deleteDoc } from 'firebase/firestore';
import { getStorage, ref, uploadBytes, getDownloadURL } from 'firebase/storage';
import * as crypto from 'crypto';
import { FetchPageResult, PaginationOptions } from '@src/_core/helper/interfaces/FetchPageResult.interface';


export class FireBaseUtilsService {

	constructor() {
		// this.jwtSecret = configService.getEnvProperty('firebase.jwt')!;
	}

	// Upload an image to Firebase Storage
	async uploadImage(base64Image: string): Promise<{ path: string; publicUrl: string } | null> {
		try {
			const fileExt = base64Image.substring("data:image/".length, base64Image.indexOf(";base64"));
			const fileName = `${crypto.randomUUID()}.${fileExt}`;
			const filePath = `images/${fileName}`;
			const base64Data = base64Image.split(',')[1];

			// Convert base64 to Uint8Array
			const byteCharacters = atob(base64Data);
			const byteNumbers = new Array(byteCharacters.length).fill(0).map((_, i) => byteCharacters.charCodeAt(i));
			const byteArray = new Uint8Array(byteNumbers);

			// Create a reference to the storage location
			const storage = getStorage();
			const storageRef = ref(storage, filePath);
			await uploadBytes(storageRef, byteArray, { contentType: `image/${fileExt}` });

			// Get public URL of the uploaded image
			const publicUrl = await getDownloadURL(storageRef);

			return { path: filePath, publicUrl };
		} catch (error) {
			console.error('Error uploading image:', error);
			return null;
		}
	}
	// Register user using Firebase Auth
	async registerUser(email: string, password: string): Promise<any> {
		try {
			const auth = getAuth();
			const userCredential = await createUserWithEmailAndPassword(auth, email, password);
			return userCredential.user;
		} catch (error) {
			console.error('Error registering user:', error);
			throw error;
		}
	}
	// Check for duplicate email (this is usually handled by Firebase automatically on signup)
	async checkDuplicateEmail(email: string): Promise<boolean> {
		try {
			const db = getFirestore();
			const usersRef = collection(db, 'users');
			const q = query(usersRef, where('email', '==', email));
			const querySnapshot = await getDocs(q);
			return !querySnapshot.empty;
		} catch (error) {
			console.error('Error checking duplicate email:', error);
			throw error;
		}
	}

	// Fetch object by ID from Firestore
	async fetchObjectById(collectionName: string, objectId: string): Promise<any> {
		const db = getFirestore();
		const docRef = doc(db, collectionName, objectId);
		const docSnap = await getDoc(docRef);
		if (docSnap.exists()) {
			return docSnap.data();
		} else {
			console.log("No such document!");
			return null;
		}
	}

	// Fetch multiple objects with conditions from Firestore
	async fetchObjects(collectionName: string, conditions?: Record<string, any>): Promise<any[]> {
		try {
			const db = getFirestore();
			const collectionRef = collection(db, collectionName);
			let q = query(collectionRef);
			if (conditions) {
				for (const key in conditions) {
					q = query(q, where(key, '==', conditions[key]));
				}
			}
			const querySnapshot = await getDocs(q);
			return querySnapshot.docs.map(doc => doc.data());
		} catch (error) {
			console.error(`Error fetching objects from ${collectionName}:`, error);
			throw error;
		}
	}

	// Fetch objects with pagination
	async fetchObjectsWithPagination<T>(
		collectionName: string,
		paginationOptions: PaginationOptions
	): Promise<FetchPageResult<T>> {
		try {
			const db = getFirestore();
			const collectionRef = collection(db, collectionName);

			let q = query(collectionRef, orderBy('createdAt'));

			// Apply filters if provided
			if (paginationOptions.filters) {
				paginationOptions.filters.forEach((filter: any) => {
					switch (filter.operator) {
						case 'eq':
							q = query(q, where(filter.key, '==', filter.value));
							break;
						case 'neq':
							q = query(q, where(filter.key, '!=', filter.value));
							break;
						case 'gt':
							q = query(q, where(filter.key, '>', filter.value));
							break;
						case 'gte':
							q = query(q, where(filter.key, '>=', filter.value));
							break;
						case 'lt':
							q = query(q, where(filter.key, '<', filter.value));
							break;
						case 'lte':
							q = query(q, where(filter.key, '<=', filter.value));
							break;
						case 'like':
							// Firestore doesn't natively support LIKE, but if you want to simulate it
							q = query(q, where(filter.key, '>=', filter.value), where(filter.key, '<=', filter.value + '\uf8ff'));
							break;
						default:
							throw new Error(`Unsupported filter operator: ${filter.operator}`);
					}
				});
			}

			// Apply pagination if `all` is not set to true
			if (!paginationOptions.all) {
				const pageSize = paginationOptions.pageSize ?? 10;
				q = query(q, limit(pageSize));

				if (paginationOptions.page && paginationOptions.page > 1 && paginationOptions.lastVisible) {
					q = query(q, startAfter(paginationOptions.lastVisible));
				}
			}

			// Execute the query and fetch the documents
			const querySnapshot = await getDocs(q);
			const data = querySnapshot.docs.map(doc => ({
				...doc.data(),
				id: doc.id, // Include document ID in the result
			}));

			const lastVisible = querySnapshot.docs[querySnapshot.docs.length - 1];
			console.log('lastVisible', lastVisible);

			// Calculate total pages and return result
			const total = querySnapshot.size;
			const count = data.length;
			const totalPages = paginationOptions.pageSize ? Math.ceil(total / paginationOptions.pageSize) : 1;

			return {
				data,
				total,
				count,
				page: paginationOptions.page,
				totalPages,
				limit: paginationOptions.pageSize,
			};
		} catch (error) {
			console.error('Error fetching objects with pagination:', error);
			throw error;
		}
	}

	// Update object in Firestore
	async updateObject(collectionName: string, objectId: string, data: any): Promise<void> {
		const db = getFirestore();
		const docRef = doc(db, collectionName, objectId);
		await setDoc(docRef, data, { merge: true });
		console.log('Document updated successfully.');
	}

	// Create object in Firestore
	async createObject(collectionName: string, data: any): Promise<any> {
		try {
			const db = getFirestore();
			const docRef = doc(collection(db, collectionName)); // Creates a new document reference with an auto-generated ID
			await setDoc(docRef, data); // Set the document data

			// Retrieve the full object, including the document ID
			const createdObject = { ...data, id: docRef.id };

			console.log('Document created successfully:', createdObject);
			return createdObject; // Return the full object including the auto-generated ID
		} catch (error) {
			console.error('Error creating document:', error);
			throw error;
		}
	}

	// Delete object from Firestore
	async deleteObject(collectionName: string, objectId: string): Promise<void> {
		const db = getFirestore();
		const docRef = doc(db, collectionName, objectId);
		await deleteDoc(docRef);
		console.log('Document deleted successfully.');
	}

	// Count total objects in Firestore collection
	async fetchTotalCount(collectionName: string): Promise<number> {
		const db = getFirestore();
		const collectionRef = collection(db, collectionName);
		const querySnapshot = await getDocs(collectionRef);
		return querySnapshot.size;
	}

	// Authenticate with a custom token (used in some backend services)
	async authenticateWithCustomToken(token: string): Promise<void> {
		try {
			const auth = getAuth();
			await signInWithCustomToken(auth, token);
			console.log('Authenticated with custom token.');
		} catch (error) {
			console.error('Error authenticating with custom token:', error);
			throw error;
		}
	}

	async signInWithEmailAndPassword(email: string, password: string): Promise<any> {
		try {
			const auth = getAuth();
			const userCredential = await signInWithEmailAndPassword(auth, email, password);
			return userCredential.user;
		} catch (error) {
			console.error('Error signing in:', error);
			throw error;
		}
	}

	// Fetch all users (for admin purposes)
	async adminFetchUsers(): Promise<any[]> {
		try {
			const db = getFirestore();
			const usersRef = collection(db, 'users');
			const querySnapshot = await getDocs(usersRef);
			return querySnapshot.docs.map(doc => doc.data());
		} catch (error) {
			console.error('Error fetching users:', error);
			throw error;
		}
	}
}

================================================
File: src/utils/get-all-files.ts
================================================
const path = require('path');
const fs = require('fs').promises;
// Function to get all files recursively
export async function getAllFiles(dirPath: string): Promise<any[]> {
    try {
        const entries = await fs.readdir(dirPath, { withFileTypes: true });
        const files = await Promise.all(entries.map(async (entry: any) => {
            const fullPath = path.join(dirPath, entry.name);
            
            if (entry.isDirectory()) {
                // If it's a directory, recurse into it
                const subFiles = await getAllFiles(fullPath);
                return {
                    type: 'directory',
                    name: entry.name,
                    path: fullPath,
                    files: subFiles
                };
            } else {
                // If it's a file, get its stats
                const stats = await fs.stat(fullPath);
                return {
                    type: 'file',
                    name: entry.name,
                    path: fullPath,
                    size: stats.size,
                    created: stats.birthtime,
                    modified: stats.mtime
                };
            }
        }));

        return files;
    } catch (error) {
        console.error(`Error reading directory: ${dirPath}`, error);
        throw error;
    }
}

================================================
File: src/utils/get-data.ts
================================================
import { ref, get, getDatabase, update } from "firebase/database";
import { database } from '@/_core/database/firebase-admin-sdk';

/**
 * Convert relative time string to hours
 * @param {string} timeString - Time string like "15 hours ago"
 * @returns {number} Number of hours
 */
function parseRelativeTime(timeString : string) : number {
    const match = timeString.match(/(\d+)\s+(hour|hours|day|days)\s+ago/);
    if (!match) return Infinity;

    const [, number, unit] = match;
    const hours = unit.startsWith('day') ? parseInt(number) * 24 : parseInt(number);
    return hours;
}

/**
 * Retrieve and sort all content from the 'news/' node in Firebase.
 * @returns {Promise<Array>} Sorted news array
 */
export async function getAllContentFromFirebase() {
    try {
        const newsRef = ref(database, 'news/');
        const snapshot = await get(newsRef);

        if (snapshot.exists()) {
            const data = snapshot.val();
            const currentTimestamp = Date.now();

            const newsArray = Object.keys(data).map((key) => ({
                id: key,
                ...data[key],
                retrievedAt: currentTimestamp,
                hoursAgo: parseRelativeTime(data[key].time)
            }));

            // Sort the news array using multiple criteria
            newsArray.sort((a, b) => {
                // First, compare by hours ago
                const hoursDiff = a.hoursAgo - b.hoursAgo;
                if (hoursDiff !== 0) return hoursDiff;

                // If hours are same, compare by timestamp
                const timestampDiff = b.timestamp - a.timestamp;
                if (timestampDiff !== 0) return timestampDiff;

                // If timestamps are same, compare by retrievedAt
                return b.retrievedAt - a.retrievedAt;
            });

            // Remove the temporary hoursAgo property
            const cleanNewsArray = newsArray.map(({ hoursAgo, ...item }) => item);

            console.log("News data retrieved and sorted successfully:", {
                totalItems: cleanNewsArray.length,
                firstItem: cleanNewsArray[0],
                lastItem: cleanNewsArray[cleanNewsArray.length - 1]
            });

            return {
                message: "News data retrieved successfully!",
                data: cleanNewsArray
            };

        } else {
            console.log("No data available in 'news/' node.");
            return {
                message: "No news data available",
                data: []
            };
        }
    } catch (error : any) {
        console.error("Error retrieving news data from Firebase:", error);
        throw new Error(`Failed to retrieve news data: ${error.message}`);
    }
}

/**
 * Get specific news content by ID from Firebase
 * @param {string} id - The ID of the news item to retrieve
 * @returns {Promise<Object>} News item data
 */
export async function getContentById(id: string) {
    try {
        if (!id) {
            throw new Error('ID is required');
        }

        // Get a reference to the specific news item
        const newsRef = ref(database, `news/${id}`);
        const snapshot = await get(newsRef);

        if (snapshot.exists()) {
            const data = snapshot.val();
            const currentTimestamp = Date.now();

            // Return the data with additional metadata
            return {
                status: 'success',
                message: 'News item retrieved successfully',
                data: {
                    id,
                    ...data,
                    retrievedAt: currentTimestamp
                }
            };
        } else {
            return {
                status: 'error',
                message: `No news item found with ID: ${id}`,
                data: null
            };
        }
    } catch (error : any) {
        console.error("Error retrieving news item:", error);
        return {
            status: 'error',
            message: `Failed to retrieve news item: ${error.message}`,
            data: null,
            error: error.toString()
        };
    }
}


/**
 * Update timestamps for all news items in Firebase based on their relative time strings
 */
export async function updateNewsTimestamps() {
    const database = getDatabase();
    const newsRef = ref(database, 'news/');

    try {
        const snapshot = await get(newsRef);
        if (!snapshot.exists()) {
            console.log("No data available in 'news/' node.");
            return {
                message: "No news data to update",
                updatedCount: 0
            };
        }

        const data = snapshot.val();
        const currentTimestamp = Date.now();
        const updates: { [key: string]: any } = {};
        let updatedCount = 0;

        // Process each news item
        for (const [key, item] of Object.entries(data)) {
            const newsItem = item as any;
            if (!newsItem.time) continue;

            // Calculate hours ago
            const hoursAgo = parseRelativeTime(newsItem.time);
            if (hoursAgo === Infinity) continue;

            // Calculate new timestamp
            const newTimestamp = currentTimestamp - (hoursAgo * 60 * 60 * 1000);

            // Prepare update if timestamp has changed
            if (newsItem.processedTimestamp !== newTimestamp) {
                updates[`news/${key}/processedTimestamp`] = newTimestamp;
                updates[`news/${key}/lastUpdated`] = currentTimestamp;
                updatedCount++;
            }
        }

        // Apply updates if there are any
        if (Object.keys(updates).length > 0) {
            await update(ref(database), updates);
            console.log(`Successfully updated ${updatedCount} news items with new timestamps`);
        } else {
            console.log("No items needed timestamp updates");
        }

        return {
            message: "Timestamp update completed",
            updatedCount,
            timestamp: new Date().toISOString()
        };

    } catch (error: any) {
        console.error("Error updating timestamps:", error);
        throw new Error(`Failed to update timestamps: ${error.message}`);
    }
}



/**
 * Fetch the last processed data (lastNewTime and lastNewTitle) directly from the "process" table.
 */
export async function getLastProcessedData(): Promise<{
    lastNewTime?: number;
    lastNewTitle?: string;
}> {
    try {
        // Initialize the database reference to the "process" table
        const database = getDatabase();
        const processRef = ref(database, 'process');

        // Fetch the data directly from the "process" table
        const snapshot = await get(processRef);

        if (snapshot.exists()) {
            const data = snapshot.val();
            return {
                lastNewTime: data.lastNewTime || 0,
                lastNewTitle: data.lastNewTitle || '',
            };
        } else {
            console.log('No data found in the "process" table.');
            return { lastNewTime: 0, lastNewTitle: '' };
        }
    } catch (error) {
        console.error('Error fetching last processed data:', error);
        return { lastNewTime: 0, lastNewTitle: '' };
    }
}



================================================
File: src/utils/get-latest-file.ts
================================================
import fs from 'fs';
import path from 'path';

/**
 * Get the latest file in the fetch-data/tradingeconomics_com directory
 */
export function getLatestFile() {
	const baseDir = path.join(__dirname, '../../fetch-data/tradingeconomics_com'); // Adjust the path accordingly

	// Get all date folders
	const dateFolders = fs.readdirSync(baseDir).filter((folder) => {
		return fs.statSync(path.join(baseDir, folder)).isDirectory();
	});

	if (dateFolders.length === 0) {
		throw new Error('No date folders found');
	}

	// Sort date folders in descending order to get the latest one
	const latestDateFolder = dateFolders.sort((a, b) => b.localeCompare(a))[0];
	const latestDateFolderPath = path.join(baseDir, latestDateFolder);

	// Get all hour folders inside the latest date folder
	const hourFolders = fs.readdirSync(latestDateFolderPath).filter((folder) => {
		return fs.statSync(path.join(latestDateFolderPath, folder)).isDirectory();
	});

	if (hourFolders.length === 0) {
		throw new Error('No hour folders found in latest date folder');
	}

	// Sort hour folders in descending order to get the latest one
	const latestHourFolder = hourFolders.sort((a, b) => b.localeCompare(a))[0];
	const latestHourFolderPath = path.join(latestDateFolderPath, latestHourFolder);

	// Find the .txt file in the latest hour folder
	const files = fs.readdirSync(latestHourFolderPath).filter((file) => file.endsWith('.txt'));

	if (files.length === 0) {
		throw new Error('No .txt files found in latest hour folder');
	}

	// Return the full path of the latest file
	const latestFile = files[0];
	return path.join(latestHourFolderPath, latestFile);
}



================================================
File: src/utils/post-data.ts
================================================
import { get, orderByChild, push, query, ref, serverTimestamp, set, startAt } from 'firebase/database';
import fs from 'fs';
import { database } from '@/_core/database/firebase-admin-sdk'; // Import Firebase config
import { getLastProcessedData } from './get-data';
import { getLatestFile } from './get-latest-file';


export interface NewsItem {
    title: string;
    content: string;
    time: string;
    timestamp?: number;
    link: string;
}

export interface ProcessedDataPost {
    validItems: Array<NewsItem & { processedTimestamp: number }>;
    totalValidItems?: number;
    lastNewTime?: number;
    lastNewTitle?: string;
}


export interface UpdateProcess {
    lastNewTime?: number;
    lastNewTitle?: string;
}



/**
 * Post news data to Firebase after filtering by timestamp and duplicate titles.
 */
export async function postNewsDataToFirebase(): Promise<ProcessedDataPost> {
    // 1. Fetch the last processed data
    const lastProcessedData = await getLastProcessedData();
    const lastProcessedTimestamp = lastProcessedData?.lastNewTime || 0;
    const lastNewTitle = lastProcessedData?.lastNewTitle || '';
    console.log(`Last processed timestamp: ${lastProcessedTimestamp}`);
    console.log(`Last processed title: "${lastNewTitle}"`);

    // Initialize result variables
    const validItems: Array<NewsItem & { processedTimestamp: number }> = [];
    let totalValidItems = 0;
    let latestProcessedTimestamp = lastProcessedTimestamp;
    let latestNewTitle = lastNewTitle;

    try {
        // 2. Get the latest file path
        const latestFilePath = getLatestFile();
        console.log(`Latest file found: ${latestFilePath}`);

        // 3. Read and parse the file data
        const fileData = fs.readFileSync(latestFilePath, 'utf8');
        const parsedData: NewsItem[] = JSON.parse(fileData);

        // 4. Firebase references
        const newsRef = ref(database, 'news');
        const processRef = ref(database, 'process');

        // 5. Define current time
        const currentTime = new Date().getTime();

        // 6. Filter and post new items
        for (const newsItem of parsedData) {
            const processedTimestamp = convertRelativeTime(newsItem.time);

            // Skip old items (> 48 hours)
            if (currentTime - processedTimestamp > 48 * 60 * 60 * 1000) {
                console.log(`Skipping old item: ${newsItem.title}`);
                continue;
            }

            // Skip already processed items based on timestamp
            if (processedTimestamp <= lastProcessedTimestamp) {
                console.log(`Skipping already processed item: ${newsItem.title}`);
                continue;
            }           

            // Push new item to Firebase
            await push(newsRef, {
                ...newsItem,
                processedTimestamp,
                createdAt: serverTimestamp(),
                updatedAt: serverTimestamp(),
            });

            // Add to valid items
            validItems.push({
                ...newsItem,
                processedTimestamp,
            });

            // Update latest processed info
            totalValidItems++;
            if (processedTimestamp > latestProcessedTimestamp) {
                latestProcessedTimestamp = processedTimestamp;
                latestNewTitle = newsItem.title;
            }
        }

        console.log(`Successfully posted ${totalValidItems} new items to Firebase.`);

        // 7. Update the 'process' table with the latest data
        if (totalValidItems > 0) {
            await set(processRef, {
                lastNewTime: latestProcessedTimestamp,
                lastNewTitle: latestNewTitle,
            });
            console.log(
                `Updated 'process' table with lastNewTime: ${latestProcessedTimestamp} and lastNewTitle: "${latestNewTitle}"`
            );
        } else {
            console.log('No new items to update in the process table.');
        }

        // 8. Return the ProcessedDataPost object
        return {
            validItems,
            totalValidItems,
            lastNewTime: latestProcessedTimestamp,
            lastNewTitle: latestNewTitle,
        };
    } catch (error) {
        console.error('Error posting data to Firebase:', error);
    }

    // 9. Return an empty response in case of failure
    return {
        validItems: [],
        totalValidItems: 0,
        lastNewTime: lastProcessedTimestamp,
        lastNewTitle,
    };
}



function convertRelativeTime(relativeTime: string): number {
    const now = new Date().getTime();
    const timeString = relativeTime.toLowerCase();
    
    // Extract number and unit from time string
    const match = timeString.match(/(\d+)\s*(hour|minute|second)s?\s*ago/);
    if (!match) return now; // Default to current time if format doesn't match
    
    const [_, amount, unit] = match;
    const value = parseInt(amount);
    
    switch (unit) {
        case 'hour':
            return now - (value * 60 * 60 * 1000);
        case 'minute':
            return now - (value * 60 * 1000);
        case 'second':
            return now - (value * 1000);
        default:
            return now;
    }
}

// function getTimestampFromFirebaseItem(item: any): number {
//     // First try to get the processed timestamp
//     if (item.processedTimestamp) {
//         return item.processedTimestamp;
//     }
    
//     // If no processed timestamp, try to get it from the time field
//     if (item.time) {
//         // Handle relative time strings
//         if (typeof item.time === 'string' && item.time.toLowerCase().includes('ago')) {
//             return convertRelativeTime(item.time);
//         }
//         // Handle direct date strings
//         return new Date(item.time).getTime();
//     }
    
//     // If no valid timestamp found, return current time
//     return new Date().getTime();
// }





/**
 * Preview processed data: Filter items not in Firebase news and within 48 hours.
 */
export async function previewProcessedData(): Promise<ProcessedDataPost> {
    try {
        // 1. Fetch last processed data
        const lastProcessedData = await getLastProcessedData();
        const lastNewTime = lastProcessedData?.lastNewTime || 0;
        console.log(`Last processed time: ${lastNewTime}`);

        // 2. Fetch all news items from the last 24 hours for deduplication
        const newsRef = ref(database, 'news');
        const oneDayAgo = new Date().getTime() - 24 * 60 * 60 * 1000; // 24 hours ago
        const newsQuery = query(newsRef, orderByChild('processedTimestamp'), startAt(oneDayAgo));

        const snapshot = await get(newsQuery);
        const existingItems = snapshot.exists() ? Object.values(snapshot.val() || {}) : [];

        const existingTitles = new Set<string>();
        existingItems.forEach((item: any) => {
            if (item.title) existingTitles.add(item.title);
        });

        console.log(`Fetched ${existingTitles.size} existing titles from the last 24 hours.`);

        // 3. Get the latest file path
        const latestFilePath = getLatestFile();
        console.log(`Latest file found: ${latestFilePath}`);

        const fileData = fs.readFileSync(latestFilePath, 'utf8');
        const parsedData: NewsItem[] = JSON.parse(fileData);

        // 4. Filter new valid items
        const currentTime = new Date().getTime();
        const validItems: Array<NewsItem & { processedTimestamp: number }> = [];

        for (const newsItem of parsedData) {
            const processedTimestamp = convertRelativeTime(newsItem.time);

            // Skip old items (> 48 hours)
            if (currentTime - processedTimestamp > 48 * 60 * 60 * 1000) {
                console.log(`Skipping old item: ${newsItem.title}`);
                continue;
            }

            // Skip already processed items
            if (processedTimestamp <= lastNewTime) {
                console.log(`Skipping already processed item: ${newsItem.title}`);
                continue;
            }

            // Skip duplicates based on title
            if (existingTitles.has(newsItem.title)) {
                console.log(`Skipping duplicate title: ${newsItem.title}`);
                continue;
            }

            // Add to valid items
            validItems.push({
                ...newsItem,
                processedTimestamp,
            });
        }

        console.log(`Total new valid items ready for posting: ${validItems.length}`);
        console.table(validItems);

        // 5. Prepare and return response
        const response: ProcessedDataPost = {
            validItems: validItems,
            totalValidItems: validItems.length,
            lastNewTime: validItems.length > 0 ? validItems[validItems.length - 1].processedTimestamp : lastNewTime,
            lastNewTitle: validItems.length > 0 ? validItems[validItems.length - 1].title : lastProcessedData.lastNewTitle,
        };

        console.log('Response being returned:', response);
        return response;
    } catch (error) {
        console.error('Error previewing processed data:', error);
    }

    return {
        validItems: [],
        totalValidItems: 0,
        lastNewTime: 0,
        lastNewTitle: '',
    };
}



/**
 * Reads all data from the 'news' table, finds the latest news item (based on processedTimestamp),
 * and updates the 'process' table with lastNewTime and lastNewTitle.
 */
export async function updateLastProcessedData() : Promise<UpdateProcess> {
    try {
        // References to 'news' and 'process' tables in Firebase
        const newsRef = ref(database, 'news/');
        const processRef = ref(database, 'process/');

        console.log('Fetching all news items from Firebase...');

        // Get all data from the 'news' table
        const snapshot = await get(newsRef);
        const newsData = snapshot.val();

        // Check if data exists
        if (!newsData) {
            console.log('No news data found in Firebase.');
            return {
                lastNewTime: 0,
                lastNewTitle: '',
            };
        }

        let lastNewTitle: string | null = null;
        let lastNewTime: number | null = null;

        // Iterate through all news items to find the latest one
        Object.values(newsData).forEach((item: any) => {
            const processedTimestamp = item.processedTimestamp || 0;

            // Update if this item has a more recent timestamp
            if (!lastNewTime || processedTimestamp > lastNewTime) {
                lastNewTime = processedTimestamp;
                lastNewTitle = item.title || 'Untitled';
            }
        });

        // Log the results
        console.log(`Latest news found: "${lastNewTitle}" at timestamp ${lastNewTime}`);

        // Update the 'process' table with the latest news data
        if (lastNewTime && lastNewTitle) {
            await set(processRef, {
                lastNewTime: lastNewTime,
                lastNewTitle: lastNewTitle,
            });
            console.log('Successfully updated the process table with the latest news data.');
        } else {
            console.log('No valid news items found to update the process table.');
        }

        return {
            lastNewTime: lastNewTime as unknown as number,
            lastNewTitle: lastNewTitle as unknown as string,
        };
    } catch (error) {
        console.error('Error reading news data or updating process table:', error);
        throw error;
    }

}





================================================
File: tsconfig.json
================================================
// {
//   "compilerOptions": {
/* Visit https://aka.ms/tsconfig to read more about this file */
/* Projects */
// "incremental": true,                              /* Save .tsbuildinfo files to allow for incremental compilation of projects. */
// "composite": true,                                /* Enable constraints that allow a TypeScript project to be used with project references. */
// "tsBuildInfoFile": "./.tsbuildinfo",              /* Specify the path to .tsbuildinfo incremental compilation file. */
// "disableSourceOfProjectReferenceRedirect": true,  /* Disable preferring source files instead of declaration files when referencing composite projects. */
// "disableSolutionSearching": true,                 /* Opt a project out of multi-project reference checking when editing. */
// "disableReferencedProjectLoad": true,             /* Reduce the number of projects loaded automatically by TypeScript. */
/* Language and Environment */
// "target": "es2016",                                  /* Set the JavaScript language version for emitted JavaScript and include compatible library declarations. */
// "lib": [],                                        /* Specify a set of bundled library declaration files that describe the target runtime environment. */
// "jsx": "preserve",                                /* Specify what JSX code is generated. */
// "experimentalDecorators": true,                   /* Enable experimental support for legacy experimental decorators. */
// "emitDecoratorMetadata": true,                    /* Emit design-type metadata for decorated declarations in source files. */
// "jsxFactory": "",                                 /* Specify the JSX factory function used when targeting React JSX emit, e.g. 'React.createElement' or 'h'. */
// "jsxFragmentFactory": "",                         /* Specify the JSX Fragment reference used for fragments when targeting React JSX emit e.g. 'React.Fragment' or 'Fragment'. */
// "jsxImportSource": "",                            /* Specify module specifier used to import the JSX factory functions when using 'jsx: react-jsx*'. */
// "reactNamespace": "",                             /* Specify the object invoked for 'createElement'. This only applies when targeting 'react' JSX emit. */
// "noLib": true,                                    /* Disable including any library files, including the default lib.d.ts. */
// "useDefineForClassFields": true,                  /* Emit ECMAScript-standard-compliant class fields. */
// "moduleDetection": "auto",                        /* Control what method is used to detect module-format JS files. */
/* Modules */
// "module": "commonjs",                                /* Specify what module code is generated. */
// "rootDir": "./",                                  /* Specify the root folder within your source files. */
// "moduleResolution": "node10",                     /* Specify how TypeScript looks up a file from a given module specifier. */
// "baseUrl": "./",                                  /* Specify the base directory to resolve non-relative module names. */
// "paths": {},                                      /* Specify a set of entries that re-map imports to additional lookup locations. */
// "rootDirs": [],                                   /* Allow multiple folders to be treated as one when resolving modules. */
// "typeRoots": [],                                  /* Specify multiple folders that act like './node_modules/@types'. */
// "types": [],                                      /* Specify type package names to be included without being referenced in a source file. */
// "allowUmdGlobalAccess": true,                     /* Allow accessing UMD globals from modules. */
// "moduleSuffixes": [],                             /* List of file name suffixes to search when resolving a module. */
// "allowImportingTsExtensions": true,               /* Allow imports to include TypeScript file extensions. Requires '--moduleResolution bundler' and either '--noEmit' or '--emitDeclarationOnly' to be set. */
// "resolvePackageJsonExports": true,                /* Use the package.json 'exports' field when resolving package imports. */
// "resolvePackageJsonImports": true,                /* Use the package.json 'imports' field when resolving imports. */
// "customConditions": [],                           /* Conditions to set in addition to the resolver-specific defaults when resolving imports. */
// "resolveJsonModule": true,                        /* Enable importing .json files. */
// "allowArbitraryExtensions": true,                 /* Enable importing files with any extension, provided a declaration file is present. */
// "noResolve": true,                                /* Disallow 'import's, 'require's or '<reference>'s from expanding the number of files TypeScript should add to a project. */
/* JavaScript Support */
// "allowJs": true,                                  /* Allow JavaScript files to be a part of your program. Use the 'checkJS' option to get errors from these files. */
// "checkJs": true,                                  /* Enable error reporting in type-checked JavaScript files. */
// "maxNodeModuleJsDepth": 1,                        /* Specify the maximum folder depth used for checking JavaScript files from 'node_modules'. Only applicable with 'allowJs'. */
/* Emit */
// "declaration": true,                              /* Generate .d.ts files from TypeScript and JavaScript files in your project. */
// "declarationMap": true,                           /* Create sourcemaps for d.ts files. */
// "emitDeclarationOnly": true,                      /* Only output d.ts files and not JavaScript files. */
// "sourceMap": true,                                /* Create source map files for emitted JavaScript files. */
// "inlineSourceMap": true,                          /* Include sourcemap files inside the emitted JavaScript. */
// "outFile": "./",                                  /* Specify a file that bundles all outputs into one JavaScript file. If 'declaration' is true, also designates a file that bundles all .d.ts output. */
// "outDir": "./",                                   /* Specify an output folder for all emitted files. */
// "removeComments": true,                           /* Disable emitting comments. */
// "noEmit": true,                                   /* Disable emitting files from a compilation. */
// "importHelpers": true,                            /* Allow importing helper functions from tslib once per project, instead of including them per-file. */
// "downlevelIteration": true,                       /* Emit more compliant, but verbose and less performant JavaScript for iteration. */
// "sourceRoot": "",                                 /* Specify the root path for debuggers to find the reference source code. */
// "mapRoot": "",                                    /* Specify the location where debugger should locate map files instead of generated locations. */
// "inlineSources": true,                            /* Include source code in the sourcemaps inside the emitted JavaScript. */
// "emitBOM": true,                                  /* Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files. */
// "newLine": "crlf",                                /* Set the newline character for emitting files. */
// "stripInternal": true,                            /* Disable emitting declarations that have '@internal' in their JSDoc comments. */
// "noEmitHelpers": true,                            /* Disable generating custom helper functions like '__extends' in compiled output. */
// "noEmitOnError": true,                            /* Disable emitting files if any type checking errors are reported. */
// "preserveConstEnums": true,                       /* Disable erasing 'const enum' declarations in generated code. */
// "declarationDir": "./",                           /* Specify the output directory for generated declaration files. */
/* Interop Constraints */
// "isolatedModules": true,                          /* Ensure that each file can be safely transpiled without relying on other imports. */
// "verbatimModuleSyntax": true,                     /* Do not transform or elide any imports or exports not marked as type-only, ensuring they are written in the output file's format based on the 'module' setting. */
// "isolatedDeclarations": true,                     /* Require sufficient annotation on exports so other tools can trivially generate declaration files. */
// "allowSyntheticDefaultImports": true,             /* Allow 'import x from y' when a module doesn't have a default export. */
// "esModuleInterop": true,                             /* Emit additional JavaScript to ease support for importing CommonJS modules. This enables 'allowSyntheticDefaultImports' for type compatibility. */
// "preserveSymlinks": true,                         /* Disable resolving symlinks to their realpath. This correlates to the same flag in node. */
// "forceConsistentCasingInFileNames": true,            /* Ensure that casing is correct in imports. */
/* Type Checking */
// "strict": true,                                      /* Enable all strict type-checking options. */
// "noImplicitAny": true,                            /* Enable error reporting for expressions and declarations with an implied 'any' type. */
// "strictNullChecks": true,                         /* When type checking, take into account 'null' and 'undefined'. */
// "strictFunctionTypes": true,                      /* When assigning functions, check to ensure parameters and the return values are subtype-compatible. */
// "strictBindCallApply": true,                      /* Check that the arguments for 'bind', 'call', and 'apply' methods match the original function. */
// "strictPropertyInitialization": true,             /* Check for class properties that are declared but not set in the constructor. */
// "noImplicitThis": true,                           /* Enable error reporting when 'this' is given the type 'any'. */
// "useUnknownInCatchVariables": true,               /* Default catch clause variables as 'unknown' instead of 'any'. */
// "alwaysStrict": true,                             /* Ensure 'use strict' is always emitted. */
// "noUnusedLocals": true,                           /* Enable error reporting when local variables aren't read. */
// "noUnusedParameters": true,                       /* Raise an error when a function parameter isn't read. */
// "exactOptionalPropertyTypes": true,               /* Interpret optional property types as written, rather than adding 'undefined'. */
// "noImplicitReturns": true,                        /* Enable error reporting for codepaths that do not explicitly return in a function. */
// "noFallthroughCasesInSwitch": true,               /* Enable error reporting for fallthrough cases in switch statements. */
// "noUncheckedIndexedAccess": true,                 /* Add 'undefined' to a type when accessed using an index. */
// "noImplicitOverride": true,                       /* Ensure overriding members in derived classes are marked with an override modifier. */
// "noPropertyAccessFromIndexSignature": true,       /* Enforces using indexed accessors for keys declared using an indexed type. */
// "allowUnusedLabels": true,                        /* Disable error reporting for unused labels. */
// "allowUnreachableCode": true,                     /* Disable error reporting for unreachable code. */
/* Completeness */
// "skipDefaultLibCheck": true,                      /* Skip type checking .d.ts files that are included with TypeScript. */
// "skipLibCheck": true                                 /* Skip type checking all .d.ts files. */
//   }
// }
{
	"compilerOptions": {
		/* Language and environment settings */
		"target": "ES2020", // Modern JavaScript version
		"module": "commonjs", // CommonJS module system for Node.js
		"lib": [
			"ES2020"
		], // Use modern JavaScript library features
		"moduleResolution": "node", // Resolve modules in Node.js style
		"esModuleInterop": true, // Ensures compatibility with CommonJS and ES modules
		"allowSyntheticDefaultImports": true, // Allows default imports from non-ES6 modules
		/* Code checking and strictness */
		"strict": true, // Enable all strict type checking options
		"noImplicitAny": true, // Raise errors on expressions and declarations with an implied `any` type
		"strictNullChecks": true, // Ensure `null` and `undefined` are distinct types
		"strictFunctionTypes": true, // Enforces safer function typing
		"strictBindCallApply": true, // Check stricter `bind`, `call`, and `apply` methods
		"forceConsistentCasingInFileNames": true, // Enforce consistent file name casing
		/* Output settings */
		"rootDir": "./src", // Root directory of TypeScript files
		"removeComments": true, // Remove comments in the output
		"sourceMap": true, // Generate corresponding `.map` files
		/* Additional options */
		"skipLibCheck": true, // Skip type checking of declaration files
		"resolveJsonModule": true, // Allows importing JSON files
		"isolatedModules": true, // Ensures that each file can be safely transpiled
		"noUnusedLocals": true, // Error when there are unused local variables
		"noUnusedParameters": true, // Error when there are unused parameters
		"noFallthroughCasesInSwitch": true, // Prevent fallthrough cases in switch statements
		"allowJs": false, // Disallow JavaScript files
		"checkJs": false, // Do not check JavaScript files
		"incremental": true, // Enable incremental compilation for faster builds
		"baseUrl": ".",
		"emitDecoratorMetadata": true,
    	"experimentalDecorators": true,
		"outDir": "dist",
		"paths": {	
			"@/*": ["src/*"],
			"@src/*": ["src/*"],
			"@scripts/*": ["src/scripts/*"],
			"@utils/*": ["src/utils/*"],
			"@modules/*": ["src/modules/*"],
			"@server/*": ["src/_core/server/*"],
			"@database/*": ["src/_core/database/*"],
			"@env/*": ["src/_core/config/*"],
			"@node_modules/*": ["node_modules/*"],
			"@environment/*": ["environment/*"],
			"@config/*": ["src/_core/config/*"],
			"@_core/*": ["src/_core/*"],
			"@auth/*": ["src/_core/auth/*"],

		}
	},
	"include": [
		"src/**/*"
	],
	"exclude": [
		"node_modules",
		"dist"
	]
}
